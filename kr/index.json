[{"body":"","link":"https://dahjeong.github.io/kr/","section":"","tags":null,"title":""},{"body":"","link":"https://dahjeong.github.io/kr/books/","section":"books","tags":null,"title":""},{"body":"","link":"https://dahjeong.github.io/kr/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://dahjeong.github.io/kr/categories/essay/","section":"categories","tags":null,"title":"Essay"},{"body":"[마루야마 겐지]\n요즘, 유학을 시작할 때 읽었던 책들을 다시 읽어보고 있다. 그때의 내게 영향을 끼쳤던 글들은 무엇이었을까? 다시 살펴보고 싶다.\n이 책은 가족, 사회, 국가, 종교로부터 독립해야한다는 생각을 담고 있다. 나와 가족, 사회 국가, 종교와의 관계를 '동물적'으로 표현했다고 말하고 싶다. 이 관계들에 대한 작가의 시선은 교육으로 주입된 어떤 옳고 그름을 벗어던졌다. 그리고 날 것 그대로를 바라보았다. 사실, 종교나 국가, 혹은 사회로부터의 독립은 많은 사람이 당연하다고 받아들일 수 있다. 하지만 가족으로부터의 독립은 꽤 많은 사람에게 불편하게 다가갈 수 있다고 생각한다. 특히 이 책 1장의 제목인 부모를 버려라, 그래야 어른이다. 는 제목부터가 한국에서 오랫동안 받아온 유교 교육에 반하는 문장임과 더불어 '버려라.'라는 단어가 주는 부정적인 어감이 우리를 불편하게 만든다. 하지만 나는 가족과 부모를 떠나야 한다. 라는 말에 격하게 공감했었고 지금도 이 생각은 변함이 없다.\n내가 유학을 시작한 나이는 34세, 그 나이쯤 되면 보통은 다른 가정을 이루면서 자연스럽게 독립한다. (이것 또한 마루야마 겐지가 말하는 완벽한 독립은 아니지만, 부모와 심리적인 거리를 늘릴 수 있는 하나의 계기가 된다) 하지만 나는 내 가정을 일구지도 않았고 30년은 넘게 한국에 살면서 내 머릿속에 자연스럽게 주입된 가족과 부모에 대한 이상한 연민과 믿음으로 가족으로부터 완벽히 독립하지 못한 상태였었다. 따로 살긴 했지만 그런 물리적 독립이 아니라, 어떻게 해서든 혼자 살아남아야 한다는 개념이 없었던 것 같다. 회사를 그만두고 유학을 준비하는 과정에서 완벽한 가정에 대한 허상이 나를 얼마나 괴롭히고 있는가를 깨달았다. 그리고 그것을 벗어나고 가족으로부터 완벽하게 독립하는 것이 힘들지만 내 인생을 내 뜻대로 살기에 가장 필요한 것이라고 깨달았다. 이 책은 그 생각을 더 굳건히 해 주었던 것 같다. 지금 나는 나를 도와줄 사람이 아무도 없는 곳에 혼자 떨어졌다. 어떻게든 혼자 살아남아야 한다. 부모에게 기대는 순간, 내 삶은 내가 마음대로 할 수 없다. 잔소리하지 말라는 말을 당당하게 할 수 없고, 내 인생의 결정을 허락받아야 하고 평가받아야 한다. 또 나에게 거는 부모의 기대와 희생으로 그들의 인생 또한 불행해진다. 이것을 평생 기억하며 살기를 바란다.\n이 책에서 또 하나 크게 공감이 갔던 것은 대학 학위에 대한 작가의 의견이다. \u0026quot;단순히 사회적 값어치를 매기는 데 목적이 있는 학력을 그렇게나 중시하는 까닭은 오로지 순종할 인물인지 아닌지를 확인하기 위해서다. 세상의 가치관에 어디까지 순종적일 수 있는지, 그 어처구니없는 입시 전쟁에 얼마나 투신한 인간인지를 판단하고 싶기 때문이다.\u0026quot; 회사에 다니면서 이런 비슷한 생각을 많이 했다. 직장에서 만난 대부분 사람은 사회가 매긴 어떤 값어치에서 남들보다 뛰어나게 되는 것을 지향한다. 회사가 정한 뭔지도 모르는 이상 기준으로 평가받아서, 승진이라 불리는, 월급은 쥐꼬리만큼 오르고 직함 하나 바뀌는 것을 하지 못하면 패배자라는 기분에 둘러싸이게 된다. 이런 제도에 잘 적응해서 남보다 뛰어난 자가 되고자 승진에 욕심부리는 인간들은 대부분 좋은 대학을 나온 사람들이다. 게네들은 쭉 그런 식으로 자신을 증명하면서 살았고 그런 시스템에서 치열하게 경쟁할 것을 잘 알기 때문에 대기업에서는 학력 좋은 사람을 뽑는다. 회사 인사과에서는 이런 것을 이용하기 위해서 직급을 더 쪼개서 승진하는 기분은 느끼게 해준다. 그러면 회사에 충성하며 살 테니까, 회사는 직원들을 그런 식으로 이용하지…\n국가라는 테두리도 애국심이라는 말도 안 되는 관념을 교육으로 세뇌해서 실체도 없는 무언가에 충성하게 만든다. 사실은 국가라는 것은 없고 그 안에 권력을 가진 사람들이 존재한다고 생각한다. 국민들이 부여한 그 권력은 국민의 평안함 삶을 위해서 serve 하는 사람들에게 주어지는 것이어야 하지만 현실은 그렇지 않다. 국가 권력을 지닌 자들은 국민들 위에 군림하고 자신의 지위를 뽐낸다. 애국하고 국가에 충성을 다하는 삶을 살아가는 것은 사실 잘 살펴보면 실체가 없는 국가 대신에 그 안에 권력을 가진 사람들에게 더 많은 힘을 실어주는 것이다.\n중공업에 다닐 때 우수사원에 뽑혀서 어떤 교육을 받으러 간 적이 있다. 그 교육의 핵심은 자동차 철강 조선업이 대한민국을 먹여 살리고 있으니 너희들은 자부심을 가지고 일하라는 내용이었다. 대한민국은 무엇이며 내가 먹여 살리고 있는 것은 무엇일까? 회사는 월급을 한 푼도 쓰지 않고 20년을 모아도 서울에 적당한 집 한 채 사기도 어려운, 그런 가치의 돈을 주면서 너희가 먹여 살리고 있는 것은 대한민국이다. 라는 허상의 자부심을 심어주고 내 인생을 받아 갔다. 국가 발전이라는 이름으로 개인의 희생을 정당화한다. 하지만 그 실체를 잘 봐야 한다. 그 희생에 이득을 얻는 자들이 누구인지.\n이 책을 읽고 나서, 죽기 전까지 독립된 인간으로서 삶을 살아나기 위해서 앞으로의 내 인생을 어떻게 살아야 할지 고민을 많이 했었다. 나 자신을 브랜딩해서 먹고 살되, 대중의 사랑을 받는 어떤 것이 아니라 사람들의 삶에 필요한 어떤 것을 제공하는 자로 살고 싶다. 박사과정이 끝나는 이 시점에서 이 책을 다시 읽으며, 한 번 더 내 삶의 방향을 바로 잡았다. 앞으로 잘해보자!\n","link":"https://dahjeong.github.io/kr/books/life/","section":"books","tags":null,"title":"인생 따위 엿이나 먹어라"},{"body":"[김이나]\n김이나 작사가의 책, 보통의 언어들을 읽었다. 보통의 언어란 제목을 붙인 것은, 노래에 붙여진 말들이 아니라 그냥 우리가 보통 말할 때 쓰는 언어에 대해서 말하는 책이라는 뜻일까? 여튼, 이 책은 몇가지 일상의 단어에 대한 그녀의 해석이 담겨져 있는 책이었다. 짧기도 했지만 금방 읽혔다.\n예전에 어디선가 김이나 작사가가 '말의 맛'이라는 단어를 사용한 것을 들었었다. '말의 맛'이라니… '늬앙스'라는 단어를 참… 한국적으로 잘 표현할 수 있는 단어다 라고 생각했었다. 하나의 말은 듣는 사람들의 개인의 경험에 따라서 여러가지 의미로 다르게 받아들일 수도 있다. 이 말의 맛을 잘 사용하면 글의 의미가 명료해진다고 생각한다. 김이나 작사가의 글에는 이 '말의 맛'이 굉장히 예민하게 표현되어 있다고 느낀다. 그래서 그녀의 글은 쉽게 읽히는 것 같다.\n그녀의 글의 또 하나는 장점은 단어를 다각도에서 바라본다고나 할까? '말의 맛'을 잘 사용하려면 단어가 어떤 용도로 사용되고 있는지 잘 알아야 하는데 그 용도를 다각도로 바라보고 용도의 공통점을 파악하고 그것을 더 깊게 생각해 보는 것 같다. 그런 그녀의 생각들이 보통의 언어라는 책에 잘 그려져 있었다.\n이 책을 읽고 나서, 나도 단어를 좀 더 예민하게 잘 쓰고 싶다는 생각이 들었다. 언젠가는 나도 책을 쓰고 싶다. 그게 재미없는 공학책일 수도 있지만, 김이나 작사가의 책처럼 말의 맛을 잘 사용해서 쓰여지면 좋겠다. 그래서 읽는 사람이 힘들여 이해하려고 머리를 쓰지 않아도 쉽게 읽히는 그런 책이면 좋겠다.\n","link":"https://dahjeong.github.io/kr/books/language/","section":"books","tags":null,"title":"나를 숨 쉬게 하는 보통의 언어들"},{"body":"[레너드 믈로디노프]\n최근에 박사학위 디펜스를 마쳤다. 몇몇 교수님들이 연구 내용에 대해서 인상적이라는 평가를 주셨다. 하지만 나 스스로는 뭔가가 만족스럽지 않았다. 4년 동안의 결실로 그럴싸해 보이는 뭔가를 만들어 내긴 했는데, 사실 내 연구가 어디에 어떤 기여를 할 수 있을지 모르겠고 솔직히, 열심히 똥을 만들어낸 기분이었다. 디펜스를 마치고 맞이한 첫 주말에, 유학을 시작하기 전에 읽었던 이 책이 생각났다. \u0026quot;파인만에게 길을 묻다\u0026quot; 이 책은 저자인 레너드 믈로디노프가 박사학위를 마치고 막 독립연구자로서의 삶을 시작하며 시기에 그의 고민과 고민에 대한 답을 찾아 나가는 과정에서 리처드 파인만과 나눈 대화들을 담은 책이다. 인터넷 리뷰를 보면, 이 책을 읽은 대부분의 독자는 가슴이 뛰는 일을 하라는 파인만의 말에 큰 무게를 두는 것 같다. 하지만 나는 저자가 만든 자기 삶의 경계? 가 좋았다. 예를 들어 아래 두 구절은 자기 삶을 살아나가는 과정에서 적어도 어떤 방향으로는 향하지 않겠다. 라는 경계를 만든 것으로 생각한다. 삶의 목표를 정확히 세우는 것은 그 목표를 위해서 어떤 행위도 허용되어야 할 것 같지만 경계를 쳐서 폭을 좁히는 것이 더 넓은 자신을 만드는 방법이 아닐까? 라는 생각이다.\n\u0026quot;그러나 나는 별 쓸모없는 물건들을 집안에 잔뜩 쌓아놓기 위해 좋아하지도 않는 일에 아주 긴 시간을 시달리다가 수십년 뒤 허비한 세월을 후회하는 어른들을 너무나 많이 보았다. 그리고 나의 아버지가 단지 먹고 살기 위해 오랫동안 힘든 일을 하는 것을 지켜보았다. 나는 마음속으로 아버지보다는 나은 삶을 살겠다고 맹세하고 있었다. 최고의 자산은 내가 하고 싶은 일을 하면서 사는 능력이라고 생각했다.\u0026quot;\n\u0026quot;나는 몇 년 후면 나도 완전히 끝장이 나고 나의 이웃처럼 방위산업체에서 우울한 일을 해야 할 것이라고 상상했다. 그러나 내가 미사일을 설계하는 모습은 도저히 떠올릴 수가 없었다. 적어도 그 미사일을 누구한테 사용하는가 하는 문제에 대한 결정권이 없는 상태에서는 그럴수가 없었다.\u0026quot;\n나는 사실 파인만 아저씨를 잘 모른다. 이름은 많이 들어봤고 파인만의 물리학 강의 책이 유명하다는 것은 알고 있지만 그가 물리학자로서 어떤 업적을 남겼는지 잘 모른다. 그리고 물리학자로서 엄청난 업적을 이루었다고 하더라도 그를 인류의 철학적 고민에 답을 가지고 있는 스승처럼 바라보는 것은 싫다. 하지만 이 책에 기록된 파인만의 말이 그가 연구자로서 가지고 있는 어떤 태도를 보여주고, 개인적으로는 그것에서 배울 점이 많았다.\n\u0026quot;글쎄, 나는 나 자신말고는 다른 사람들한테 뭐가 좋은지 잘 몰라서 말이야.\u0026quot;\n자기 자신의 기준에서 남을 평가하지 않는다는 것이 좋다. 물리학자가 위대하다고 생각하거나 학문에 서열을 두거나 하지 않는다는 것을 간접적으로 보여준다.\n\u0026quot;사실 우리가 하는 일은 일반적이고 정상적인 것 가운데 한 특정한 종류를 남들보다 훨씬 더 많이 하는 것뿐일쎄!...... 과학자에게 보통 사람들과 다른 점이 있다면, 그 일을 아주 집중적으로 하기 때문에 오랜세월동안 한정된 주제 위에 많은 경험이 쌓이게 되었다는 것뿐일세…...나와는 달리 같은 무제를 매일 생각하지 않아. 오직 나같은 천치만 그렇게 한다네...\u0026quot;\n나 자신이 남들보다 뛰어나기 때문에 어떤 문제를 다른 사람 말고 내가 해결할 수 있다는 것보다 누구나 할 수 있지만 내가 더 열렬히 고민하기 때문에 높은 가능성으로 그 문제를 해결할 수 있다고 믿는 것! 이 연구에 최선을 다할 수 있는 큰 가정인 것 같다.\n\u0026quot;내가 택하는 방법을 다른 사람들도 생각하고 있을 가능성이 높다는 것도 알아, 하지만 상관없네. 나는 나 자신을 속여서 나에게 가능성이 더 크다고 생각을 하지.\u0026quot;\n\u0026quot;내 말은 그저, 자네가 뭘 택하든 간에 스스로 가장 악질적인 비판자가 되라는 말일세. 또 엉뚱한 이유때문에 그 일을 하지는 말라는 걸세. 자네 자신이 진심으로 믿지 않는다면 하지 말게. 뜻대로 안 되면 많은 시간을 낭비하는 셈이 되니까\u0026quot;\n\u0026quot;원숭이가 할 수 있다면 자네도 할 수 있다.\u0026quot; 그는 그렇게 말했다. 하지만 나는 원숭이가 아니었다. 나는 결과가 어떻게 될지 걱정했지만 원숭이는 그런 걱정을 하지 않을 것 같았다. 그것이 나이가 들면서 배우게 되는 것일까? 모든 것이 생각만큼 복잡하고 중요하지 않다는 것을?\n\u0026quot;그런데 이제는 답을 찾은 것 같구먼, 자네가 물리학을 좋아하는 것은 자네가 열심히 생각하는 것을 좋아하기 때문이고, 창의적인 것을 좋아하기 때문이고, 문제 풀기를 좋아하기 때문이지.\u0026quot;\n\u0026quot;그것은 자기 만족이었다. 파인만의 초점은 내부에 있었다. 그는 내부에 초점을 맞춤으로써 자유를 얻었다\u0026quot;\n나도 내 내부에 초점을 맞춰 스스로 만족하는 연구를 하고 싶다. 내가 지켜야 할 경계들을 잘 세우고, 시간이 오래 걸리더라도 자신에 대한 믿음을 가지고 꾸준히 연구해 나가고 싶다. 어떤 문제를 풀까도 굉장히 중요한데, 앞으로의 연구에서는 박사학위 연구를 시작할 때처럼 \u0026quot;엉뚱한 이유\u0026quot; 때문에 어떤 연구 주제를 선택하지 않으면 한다. (아주 솔직히 말하면, 박사학위 연구 주제는, 빨리 졸업해야 한다는 강박에 내가 빨리할 수 있는 어떤 주제를 택했다. 그러고 나니 다 끝내고 나서 남들의 좋은 평가에도 불구하고 허무하고 학위를 받기 위해서 연구했구나… 하는 생각에 스스로가 부끄러웠다) 이 엉뚱한 이유로 낭비하기에는 아까운 인생이지 않나. 아름답다고 생각되는 흥미로운 문제를 찾아서 스스로가 만족할 때까지 풀어보자! 그럼 내 삶도 진정으로 자유로워지겠지.\n","link":"https://dahjeong.github.io/kr/books/feyman/","section":"books","tags":null,"title":"파인만에게 길을 묻다"},{"body":"","link":"https://dahjeong.github.io/kr/optimization/","section":"optimization","tags":null,"title":""},{"body":"Gradient-Free Optimization 이건 언제 사용하는 거냐? gradient가 계산하기 복잡하거나 계산을 할 수 없는 경우(function evaluation 값이 noisy하거나 아니면 목적 함수가 continuous 하지 않거나, 블랙박스로 싸여있는 legacy 코드라 고칠수가 없는데 noisy하거나 어떤 값이 나오는지 알 수 없을 경우거나, 어떤 경우에 아예 에러가 나오는데 최적화를 수행해야 할 때)에 gradient-free optimization이 유용하게 사용될 수 있다. multi-modal function을 최적화 할때 gradient-free optimization을 사용하여 global optimum을 얻기도 하는데 gradient-free optimization이라고 해서 모든 방법이 global optimum을 주는 것은 아니다. (좀 더 정확하게 말하자면 gradient-free optimization이 global optimum을 찾는데 더 효과적이라고 하겠다.) 그리고 multi-objective optimization에서도 잘 활용될 수 있다. 하지만 그림에서와 같이 design variable의 수가 늘어나면 gradient free optimization의 fuction evaluation의 수가 크게 늘어나므로 비효율적이라고 할 수 있겠다.\nSolution methods Nelder Mead Nelder Mead는 nonlinear simplex method라고도 하는데 여기서 somplex란 hypertetrahedron이라고 2차원에서는 삼각형, 3차원에서는 피라미드 형태를 띄는 도형이다. Nelder Mead에서는 이 도형의 vertices가 decision points (design variables의 특정 값)가 된다. 따라서 design variable의 수에 따라서 hypertetrahedron의 차원이 달라지는 것이다. 이 방법은 gradient free method이니까 derivative가 필요 없다. 하지만 global minimum을 보장하지 않는 local method이다. problem size가 작으면 (less than 10 dimensions) 비교적 효율적이지만 design variable의 수가 커지면 굉장히 비효율적이다. constraint를 handling할 때 명시적으로(explicitly) 할 수가 없는 단점이 있다.\noptimum searching 방법을 좀 더 자세히 살펴보면 아래의 그림과 같다. 2차원 문제를 가정하면 왼쪽의 삼각형의 각 꼭지점의 x, y 축 position 값이 design variable의 값이라고 생각하자. 그래서 일단 저 검정 삼각형의 꼭지점 3점에서 function evaluation을 하고 가장 worst를 찾아서 그 점을 reflect 시킨다. 그러면 왼쪽 아래의 파란색 삼각형이 만들어 진다. 그리고 나서 다시 새로운 점에서 목적함수 evaluation을 해서\nrefelcted point에서의 목적 함수값이 이전 original 삼각형 vertex에서의 목적함수 평가 결과보다 좋을 경우 (여기서 좋을 경우란, minimization하고 있다면 목적함수 값이 더 작아진 경우를 말하고 maximization하고 있아면 목적함수 값이 더 커진 경우를 말한다.) Refelected point가 놓인 방향으로 확장하는 것이 더 좋은 결과를 얻을 수 있다는 것이므로 reflected point를 더 멀리, (이전 point에서 reflected point가 놓이게된 방향으로 더 긴 거리로) 확장한다. 이걸 수학적으로 나타내면, 일단 삼각형 꼭지점들 중에서 worst point를 제외하고 centroid를 구한다. 그림에서 이 centroid는 $x_c$라고 표기되어 있는데 x, y 좌표랑 헷갈리니까 나는 $p_c$라고 표기하겠다. 그리고 design variable의 갯수는 총 $n$개 이다. $$p_c = \\frac{1}{n} \\sum_{i=0}^{n-1} p^{(i)}$$ 그럼 the worst point $p^n$의 reflected point $p_r$은 아래와 같이 표시된다. $$p_r = p_c + \\alpha (p_c-p^{n})$$ 이때 $\\alpha$ 값은 '1'이다. 그리고 reflected point를 확장한 점의 위치는 $\\alpha =2$를 대입하여 계산해 주면 된다.\nrefelcted point에서의 목적 함수값이 이전 vertex값보다는 개선되었지만 original 삼각형에 있던 다른 vertex에서의 목적함수 평가 결과보다는 좋지 않은 경우 삼각형 바깥쪽으로 outside contraction을 한다. 일단 개선되었다는 것은 reflected point가 가는 방향으로 이동하는게 좋긴 좋지만 1)에서와 같이 더 멀리 보내버린다고 해서 크게 개선될 여지가 보이지 않는다는 것임. 차라리 reflction하지 않은 다른 vertices를 이동시키는게 좋을지도 모르니까 ouside contraction 시켜서 reflected point를 너무 멀리 보내지는 않는다. outside contraction 했을 때의 점의 위치는 reflected point $p_r= p_c + \\alpha (p_c-p^{n})$에서 $\\alpha$ 값을 '1'보다 작은 값은 positive 값을 취해주면 된다. 주로 $\\alpha =0.5$.\nReflected point에서의 목적 함수 값이 이전 original 삼각형의 결과보다 안 좋을 경우 삼각형 안 쪽으로 inside contraction시킨다. reflected point가 놓인 방향이 더 안 좋다는 걸 알고 있으니 아예 반대 방향으로 (original point가 놓여진 방향으로) 확장해서 가야되는데 그렇게 하지는 않는다.(사실 이게 잘 이해가 안됨) 어쨌든 orignal point가 놓여진 방향이 더 좋으니까 reflected point를 orignal point가 놓여진 방향으로 이동시키는 것이긴 하네. inner contraction 했을 때의 점의 위치는 동일하게, reflected point $p_r= p_c + \\alpha (p_c-p^{n})$에서 $\\alpha$ 값을 -1과 0사이 값을 취해주면 된다. 주로 $\\alpha =-0.5$.\nNelder Mead에서는 위의 절차를 반복해서 최적값을 구한다.\nGenetic Algorithm (유전 알고리즘) 일단 Genetic algorithm은 evolutionary algorithm (진화 알고리즘)의 한 종류이다. 이 evolutionary algorithm은 생물의 진화과정을 본따서 mutation, crossover, reproduction 같은 과정을 통해서 최적해를 찾는 방식이고 그 안에 evolution strategy (진화전략), genetic algorithm (유전 알고리즘), evolutionary programming (진화프로그래밍) 등이 있다. 그래서 evolutionary algorithm은 특정 알고리즘이 존재하는 게 아니고 카테고리를 말한다. genetic algorithm이랑 evolution stratege을 비교하면, crossover가 일어나면 genetic algorithm이고 crossover가 일어나지 않고 mutation만으로 다음 세대를 형성하는 것이 evolutionary algorithm이라고 생각하면 된다. 그럼 이 crossover나 mutation 뭐 이런게 뭐냐하면.... 그림에서와 같이 처음 Population $P_0$라는 것을 random하게 만들어 내는데 이것이 최적화의 design variables를 여러 set 생성시키는 거라고 보면 된다. 이 design variables의 set을 가지고 objective function evaluation을 한 후에 그 중에서 우수한 것들을 selection (선택) 절차를 거쳐서 Parents node (부모노드)로 설정한다. 이 Parents node 간의 crossover (교배)를 통해서 Offspring node(자식노드)들을 만들고 그 offspring 들 중에서 일부는 mutation (변이 혹은 돌연변이)를 일으켜 다음 번 design variables의 set인 Population $P_{1}$을 얻는다. 이러한 과정을 generation이라고 하고 이 generation을 거듭할 수록 population의 목적함수 값이 최적값으로 다가간다.\nGenetic algorithm은 binary와 real number 두 분류로 또 나뉜다. population을 이루는 design variables를 binary로 encoding and deconding하는 과정을 거치면서 실수를 binary로 변환해 주면서 최적화를 수행하는 것을 binary genetic algorithm이라고 한다. 이런 과정에서 Hamming cliff라는 것이 생기는데, 예를 들어서 '7' 이라는 정수를 binary로 변환하면 '0111'이고 그것보다 1이 큰 '8'의 경우에 binary로 표현하면 '1000'이다. 따라서 이 경우 정수값으로는 가까운데 binary 값은 4 자리의 값 모두를 flip 해주어야 하므로 교배의 과정을 거쳐서 생성하기 어렵다. 이런 것을 Hamming cliff라고 한다. 그리고 binary GA에서 '0'과 '1'만을 사용하지만 실제 우리는 고급 프로그래밍 언어에서 코딩하니까 machine precision을 다 쓸 수가 없다. 하지만 discrete variables에 사용하기 편하고 crossover가 real number GA 에서는 크게 자연적 의미가 없는 그저 과정인데 binary GA에서는 그래도 조금 더 parents의 특성을 가져갈 수 있는 의미를 가지게 된다. 어쨌건 real/binary GA 둘 다 stochastic한 접근이고 huristic한 방법이다.\nParticle Swarm Particle Swarm Optimization (PSO)는 새의 무리나 물고기 집단의 움직임을 모방한 최적화 방법이다. 따라서 일단 새 무리나 물고기 집단처럼 개체가 어떤 영역에 여러개 흩어져서 자기 마음대로 움직이고 있는 것을 생각해 보자. 이 개체 하나 하나가 design variables의 조합이라고 생각하면 된다. (뭔가 말이 좀 헷갈리는데, 예를 들어서 문제에 design variable가 하나이고 0과 10 사이의 어떤 값을 갖는다고 가정하면, 개체1은 0, 개체2는 1.5, 개체3은 5.3 뭐 이렇게 각자 다른 design variable 값을 나타낸다고 생각하면 된다. 말이 좀 헷갈리게 쓰여져 있는 이유는 design variable이 하나가 아닐수도 있어서 인데, 예를 들어 0과 10사이의 실수 두 개 라고 하면 개체1은 (0, 7.8) 개체2는 (2.5, 5,9) 뭐 이런식이라는 거지) 일단 개체들이 흩어져 있는 상태에서 각각 목적함수 평가를 한다. 그리고 난 다음에 다른 곳으로 이동해야할텐데 이 각각의 개체들은 각자의 velocity (vector값)라는 것을 가지고 있어서 원래 이동하던 방향이 있는다. 이것을 inertial라고 하고 이전에 이동했던 방향에 영향을 받는다. 그런데 목적함수의 값이 좋아지는 쪽(최소화의 경우 목적함수 값이 작아지는 쪽, 최대화의 경우 목적함수 값이 커지는 쪽)으로 이동해야 최적값을 찾을 수 있으므로 여기에 memory와 social이라는 두 개의 개념이 추가된다. memory는 각각의 개체가 각자 이동하다가 가장 좋았던 장소를 기억하는 것이고 social은 개체가 모인 집단 전체에서 가장 좋은 장소를 참고하는 것이다. 이 inertial, memory, and social의 방향의 vector 합이 개체가 다음으로 이동할 방향을 나타내고 이 vector의 크기가 최적화 과정에서 점점 줄어들면서 개체들이 하나의 최적해로 몰리게 된다.\n아래 그림이 이 과정을 나타내고 있다. 빨간색 점들이 각각의 개체이며 그 점들에 붙은 실선들이 개체가 이동하는 방향의 vector이다. ","link":"https://dahjeong.github.io/kr/optimization/gradient-free/","section":"optimization","tags":null,"title":"Gradient-free Optimization"},{"body":"Multiobjective Optimization 최적화 문제에서 목적함수 objective가 여러개 (주로 2, 3, 4정도) 있는 경우에 다목적 최적화 multiobjective optimization 를 수행한다. 근데 결국에는 하나를 선택해야 될 것인데 왜 다목적 최적화가 필요한 것인가? 그 이유는\nobjectives의 tradeoff를 quantify 할 수 있기 때문이다. - 보통 objectives 들에 어떤 커플링이 있는데 mutliobjective optimization을 통해서 design variable의 변화에 대한 objectives의 sensitivty 를 알 수 있어서 최종 결정에 도움을 줄 수 있다. 실제로 하나의 design을 하는게 아니라 여러 option을 어떤 executive committee 같은 곳에 제시해야 하는 경우가 있다. 이런 선택지를 family of design 이라고 할 수 있지. underlying objective가 계산할 수 없거나 너무 complex해서 계산하기 어렵거나 할 때 objective를 분리하여서 여러가지 옵션을 보는 것임 따라서 다목적 최적화의 해는 하나로 결정되지 않고 어떤 집합으로 나오는데 그걸 Pareto front 라고 한다. 아래의 그림에서 함수 $f_1$과 $f_2$가 obective values 이며 $f_1$과 $f_2$ 둘 다 작은게 좋은 거라면, 빨간색으로 표시된 점들이 pareto optimum 값들이며 non-dominated set, pareto front, pareto optimum, pareto set 이라고도 불린다. 이 non-dominated set 사이에는 어떤게 더 좋은지 알 수 없다. 하지만 파란색으로 표시된 점들과 빨간색 점을 비교하면 파란색 점들은 dominated 되었다고 하고 빨간색 점들 중에 어떤 하나는 반드시 이 파란색 점들보다 $f_1$과 $f_2$ 두 함수의 관점에서 더 나은 값이 있다.\nSolution methods Weighted sum Objective 각각에 weight을 곱하고 더해줘서 single optimization으로 만들어서 푸는 방법이다. 새 objective function은 $$\\begin{aligned} \\overline{f}(x) \u0026amp;= \\sum_{i=1}^{n_f} \\omega_i f_i (x) \\newline \\sum_{i=1}^{n_f} \\omega_i \u0026amp;= 1 \\end{aligned}$$\nWeight을 변화시키면서 pareto set을 만들수 있는데 이 방법에서는 weight을 어떻게 선택하느냐가 문제다. 그리고 pareto front의 모양에 따라서 어떤 구간의 pareto front를 아예 얻지 못할 수도 있다.\nEpsilon-constraint Method 하나의 objective를 남겨두고 다른 objective를 constraint로 취급하여 single optimization을 푸는 방법이다. objective를 이용하여 constraint를 구성할 때 epsilon을 inequality constraint의 bound로 설정한다. 이것을 수학적으로 표현하면 아래와 같다. $$\\begin{aligned} \\underset{x}{\\text{minimize}} \\quad \u0026amp; f_i \\newline \\text{subject to} \\quad \u0026amp;f_j \\leq \\epsilon \\quad \\text{for all } j \\neq i \\newline \u0026amp;g(x) \\leq 0 \\newline \u0026amp;h(x) = 0. \\end{aligned}$$\nWeighted sum에서 weight은 physical meaning은 없는 parameter이지만 여기서 $\\epsilon$은 constraint로 취급되는 objective의 제약값이 된다. ($\\epsilon$ 설정하려면 physical sense가 필요함) 그리고 weighted sum에서 pareto front의 모양에 따라서 놓칠 가능성이 있었던 pareto front 값을 epsilon-constraint에서는 구할 수 있다. 하지만 여전히 $\\epsilon$ 을 어떤 간격으로 설정할지가 문제이다.\nNormal Boundary Intersection Epsilon-constraint 방법의 $\\epsilon$ 간격 설정 문제를 해결하기 위해서 제안된 방법이다. 그래서 epsilon-constraint 방법과 비슷한다. pareto front의 두 끝점에서 linear line을 그어서 evenly spacing하고 거기의 normal한 방향에서 pareto front랑 만나는 점을 구할 수 있는 $\\epsilon$을 설정한다는 건데 자세한 건 잘 모르겠다. 아마도 다른 사람들도 어렵다고 생각해서 epsilon-constraint을 많이 쓴단다. 그렇지만 objective의 수가 많은 경우 normal boundary intersection이 좀 더 좋을 수 있다는데 왜인지 잘 모르겠음. Evolutionary Algorithm Evlotionary algorithm에서는 genetic algorithm에서 설명한 방법으로 최적화를 수행한다. single objective gradient free optimization과 다른 점은 population evaluation을 통해서 구해진 해를 탈락시키지 않고 다 가지고 있다는 것이다. 이 해들 간의 비교를 통해서 sorting하고 tournament 형식으로 non-dominated set을 찾아낸다. evolution을 반복하면서 이 sorted set을 업데이트 해 나가는데, sorted set 내부의 preto front들 사이에는 sorting하여 줄을 세울 수가 없으니까 rank라는 개념을 또 도입한다. solution의 밀도가 높은 지점을 제외하도록 밀도가 낮은 지역의 ranking을 높게 준다. 여기서 밀도 평가하는 함수를 crowding distance라고 한다. 그래서 여튼 evolution이 진행될수록 이 ranking이 높은 것이 앞으로 간 non-dominated set이 sorted set에 남아 있게 된다.\nGradient free method가 갖는 단점을 그대로 이어받아서 최적화 해를 얻는 시간이 많이 들지만 design variable의 갯수가 적을 때에는 앞에서 서술한 다른 방법들보다 좋을 수 있다.\n","link":"https://dahjeong.github.io/kr/optimization/multiobjective/","section":"optimization","tags":null,"title":"Multiobjective Optimization"},{"body":"","link":"https://dahjeong.github.io/kr/categories/optimization/","section":"categories","tags":null,"title":"Optimization"},{"body":"","link":"https://dahjeong.github.io/kr/categories/sampling/","section":"categories","tags":null,"title":"Sampling"},{"body":"Sampling Methods sampling method 중에서도 optimization에서 주로 쓰이는 방법은 random sampling, Latin Hypercube Sampling(LHS), Low-discrepancy sequences 중에 하나인 Halton sequence이다. ramdom sampling은 그냥 random하게 sample을 선택하는 방법인데 이게, 도메인을 골고루 커버하지 못 할수가 있다. 특히 sampling 수를 줄이면 결과가 더 안좋은데 그래서 Latin Hypercube Sampling이 이를 개선한다.\nLatin Hypercube Sampling 일단 LHS의 결과를 보면 아래 그림과 같다.\n가로축으로 한 칸 한 칸씩 이동하면서 보면 완전히 비어 있는 열이 없고 세로축으로 한 칸 한 칸씩 이동하면서 봐도 완전히 비어있는 행이 없다. 이렇게 되려면 일단 가로로 봤을 때 각 열(column)들에 sample이 존재할 활률이 균일해야한다. 즉 uniform distribution이어야 한다. 세로로 봤을 때도 마찬가지니까 그림으로 그리면 아래와 같겠다.\n근데 이렇게만 정해 놓으면 아래 그림과 같이 sample이 선택되는 불상사가 생길 수도 있다.\n그럼 뭘 추가해야되냐면 각 sample간의 거리를 maximize 해야 된다. 그래서 정리해 보면 sample을 각 축으로 projection했을 때 uniform distribution을 따라야하고 sample간의 거리는 최대화 되어야 한다. (여기서 꼭 uniform distribution일 필요는 없다. optimization domain의 특성을 잘 알고 있으면 거기에 맞게 다른 distribution을 적용할 수 있다.)\n이건 어디다 쓰냐? Genetic algorithm이나 Praticle Swarm, multi start gradient-based optimization의 starting point를 정할 때 쓸 수 있고 Monte carlo method, surrogate model 만들때도 쓸 수 있다.\nHalton sequence Halton sequence는 low discrepancy sequences 중에 하나 인데 여기서 low discrepancy는 sample을 생성하고 도메인이 표시했는데 어떤 작은 영역 여러개를 설정하여 그 것들 안에 있는 sample의 밀도를 비교해 보아도 크게 차이가 없다는 뜻이다. 그래서 well spreaded를 의미하는 것임.\n여기서 sequence도 중요한데, LHS의 경우에 sample 30개를 만들어서 function evaluation하고 난 다음에 sample 50개를 생성해서 비교하고 싶은데 앞전에 만들었던 set이랑 완전히 다른 50개의 sample이 생성된다. 근데 low discrepancy sequences는 sample 갯수가 30개에서 50개로 늘어나면 앞에 있던 sample set을 포함하는 set을 만들 수 있다. 그래서 iterative method에 사용하기 적합하다.\n그래서 앞에서 설명한걸 그림으로 보면 아래와 같다. i는 sample의 갯수를 나타내는데 sample의 갯수가 늘어나면서 새로 추가되는 sample이 파란색으로 표시되었다.\n이 i를 나타내는 아래의 식과 같은 sequence 라고 하자. $$i = a_0+a_1b+a_2b^2+ \\cdots + a_rb^r \\quad \\text{where } a \\in [0, b-1] $$ 여기서 base $b$는 어떤 값으로 주어지고 coefficient인 $a$를 i의 설정에 따라서 구하게 된다. a를 구하고 난 다음에 Halton sequence에서는 아래의 연산을 통해서 i번째 sample의 값을 결정한다. $$\\phi_b(i)=\\frac{P_{a_0}}{b}+\\frac{P_{a_1}}{b^2}+\\frac{P_{a_2}}{b^3}+\\cdots+\\frac{P_{a_r}}{b^{r+1}}$$ 여기 나오는 $P_{a_i}$는 또 뭐냐면 $P=[0,1, \\dots, b-1]$처럼 생긴 ramdom integer permutation (순열)인데 계수 $a_i$를 그대로 쓰지 않고 ($a_i$를 그대로쓰면 아래 그림의 왼쪽에 standard Halton sequence처럼 sample이 형성됨)이 permutation의 index라고 생각하고 순열에서 $a_i$번째에 있는 element를 꺼내와서 Halton sequence 계산에 분자로 쓴다. 그러면 아래 그림의 왼쪽에 Scrambled Halton이라고 표시되어 있는 그래프처럼 sample point들이 잘 퍼져있는 sample set이 형성된다.\n","link":"https://dahjeong.github.io/kr/optimization/sampling-methods/","section":"optimization","tags":null,"title":"Sampling Methods"},{"body":"Discrete Optimization Optimization의 Design variables가 discrete한 문제를 discrete optimization problem이라고 한다. 이는 discrete variable의 종류에 따라 3가지로 분류될 수 있다.\nbinary (0 or 1) integer (vehivle의 wheel의 갯수 등을 선택하는 문제) discrete (예를 들어 금속의 종류를 선택한다거나 등의 문제) discrte opimization은 nondeterministic polynomial time complete 이므로 solution이 최적인 것을 verify할 수 있지만 solution을 효율적으로 구하는 방법이 없다. 그래서 주로 huristic 한 방법을 이용한다.\nDiscrete optimization을 피하는 방법 Continuous variable이 discrete variable 보다 더 많은데 이 discrete variable때문에 discrete optimization을 선택해야 한다면 이것을 피하기 위해서 continuous optimization을 돌리고 discrete variable에만 round 하면 됨 그리고 그 variable을 fix한 상태에서 다시 optimization을 돌릴수도 있다. exhaustive search도 continuous variables가 많고 discrete variable의 수가 적은데 그 discrete variable의 선택지가 또 a few 일 때 사용할 수 있다. 이건 뭐냐면 그 a few 선택지의 discrete variable을 fix한 상태에서 continuous optimization을 수행하여 그 결과들끼리 비교하는 것이다. 또 마지막으로 parameterization을 바꾸는 방법이 있는데 discrete variables을 modeling을 달리하여서 continuous variable로 바꾸는 것이다.\nExmaples 1. A greedy algorithm 네트워크 optimization도 discrete optimization이라고 할 수 있는데, 주로 greedy algorithm의 concept을 이용한다. 방금 이동한 곳 주변에서 선택가능한 best option을 선택하면서 다음 단계로 나아가는 것이다. 이건 fast solution이고 반복적으로 수행해도 같은 값으로 수렴하지만 커플링을 무시하므로 아래의 그림에서처럼 global optimum으로 간다는 보장이 없다. 1번 노드에서 출발한다면 cost가 가장 작은 것이 3번 노드로 이동하는 cost=1 이다. 그래서 greedy 알고리즘음 3번 노드로 이동하고 3번 노드에서도 동일하게 cost가 가장 작은 노드로 이동하는 것을 반복하여 최종 노드로 도달하는 방법\n2. Branch and Bound discrete variables의 선택지로 tree를 만들어 tree의 branch를 타고 나가며 최적값을 찾는 방법이다. tree를 prune 해 나가는 과정에서 leaves에 bounded와 infeasible 영역이 형성되어 branch and bound라고 하는 듯. convex integer problem 에 꽤 유용하게 쓰인다. 예를 들어 아래와 같은 문제를 생각해 보자. $$\\begin{aligned} \\text{minimize} \\quad \u0026amp; -x_1-2x_2-3x_3-1.5x_4 \\newline \\text{subject to} \\quad \u0026amp; x_1 + x_2+2x_3+2x_4 \\leq 10 \\newline \u0026amp; 7x_1+8x_2+5x_3+x4=31.5 \\newline \u0026amp; x_i \\in \\mathbb{Z}^+ \\text{ for } i=1,2,3 \\newline \u0026amp;x_4 \\geq 0. \\end{aligned}$$ $x_i$가 positive integer이므로 discrete optimization인데 여기에 branch and bound method를 이용하여 풀어보자. $x_3$를 시작으로 부등식으로 구성되는 binary tree를 만들어 나가면 아래의 그림과 같다. 여기서 $f^*$가 minimum 이 되고 이때 optimum variable $x^*$는 [0,2,3,0.5]가 된다. 3. Dynamic programming (동적계획법) Dynamic programming은 하나의 최적화 문제를 여러 개의 subproblems로 쪼개서 이 subproblems의 optimal solution을 찾는 것을 반복하여 전체 proble의 optimimal solution을 찾는 방법이다. 꼭 discrete optimization에서 뿐만 아니라 continuous optimization이나 optimization 이외의 영역에서도 문제에서 반복되는 어떤 특정한 structure를 찾아서 subproblems을 풀면서 전체를 푸는 개념을 통틀어서 dynamic probramming이라고 한다. 알고리즘이라기 보다는 technique라고 하는게 더 맞을 듯. 알고리즘으로 표현할 수가 없다.\n앞에서 설명한 gready 알고리즘이랑 비슷하다고 생각할 수 있는데 gready는 현재 상태에 코 앞에 있는 subproblem 하나만 푸는 방식이지만 dynamic programming에서는 전체 영역을 subproblem들이 커버하고 있다. 이것은 dynamic programming의 구조가 Markov chain (continuous problem에서는 Markov process)의 특성 (Property)을 만족해야 하기 때문이다. 여기서 Markov chain의 특성이란 전체 history를 알지 못해도 현재의 state만 가지고 future state를 알아낼 수 있다는 것인데 (마르코브 체인은 현재 state n이 과거 한 단계 전인 n-1 state에 의해서만 결정된다 라고 주로 표현한다.) 이런 Markov property가 만족되면 optimization 문제를 구조화하여 recursive하게 풀 수 있다. (recursion이라 하면 Fibonacchi sequence를 푸는 알고리즘처럼 자기 자신 함수를 불러서 문제를 푸는 것이다.)\n주어진 state $s_i$에서 design decision $x_i$를 하면 이때의 cost function은 $c(s_i, x_i)$ 이고 이런 decision이 여러 개이면 현재와 미래의 cost의 sum의 최적값인 value function은 다음과 같이 표현할 수 있다. $$v(s_i) = \\underset{x_i,...x_n}{\\text{minimize}} \\quad c_{i}(s_i,x_i) + c_{i+1}(s_{i+1},x_{i+1}) + \\cdots + c_{n}(s_n,x_n)$$ 여기서 n은 우리가 cost를 평가하는 시점이나 구간이다. 이 value function을 recursive procedure로 나타내면 아래의 $\\textit{Bellman equation}$과 같다. $$v(s_i) = \\underset{x_i}{\\text{minimize}} \\quad c(s_i, x_i)+v(s_{i+1})$$ 이것이 Bellam의 또 principle of optimality의 수학적 표현이라고 할 수 있겠다. Principle of optimality란 주어진 문제의 최적해는 subproblem의 최적해들로 구성된다는 것이다. 위의 greedy 알고리즘에서 봤던 graph 문제를 dynamic programming 관점에서 다시 보자 이제는 마지막 도착 노드 12부터 그 앞의 노드 9, 노드 10, 노드 11까지만 있는 subproblem으로 나눠보자. 이 상태에서 cost와 next node에 관한 표를 만들어 보면 아래와 같다.\nCurrent node 9 10 11 cost 3 6 2 Next node 12 12 12 이후에 노드 9, 10, 11과 바로 연결되어 있는 노드 5, 6, 7, 8까지의 subproblem을 보자. 예를 들어 노드 5는 노드 9, 10, 11과 다 연결되어 있다. 노드 9를 거쳐서 노드 12로 이동하면 cost가 3+3=6 이 되고 노드 10을 거쳐 12로 이동하면 cost가 2+6=8, 노드 11을 거쳐 12로 이동하면 cost가 1+2=3 이 된다. 이때 minimum은 노드 11을 거쳐 12로 이동하는 것이니 위의 표는 아래와 같이 수정된다.\nCurrent node 5 9 10 11 cost 3 3 6 2 Next node 11 12 12 12 이런 과정을 반복하면 마지막에 완성되는 표는 아래와 같다.\nCurrent node 1 2 3 4 5 6 7 8 9 10 11 12 cost 10 8 12 9 3 8 7 4 3 6 2 0 Next node 2 5 6 8 11 9 11 11 12 12 12 - 그럼 결과는 1번 노드에서 2번노드 - 5번노드 - 11번 노드 - 12번 노드로 이동하는 cost 10인 route로 나온다. 이게 global optimum!!! 4. Simulated annealing Optimization 과정에서 design variables을 update할 때 어떤 확률분포에 의해서 design variable을 선택하는 방법이다. local minimum에 빠지지 않고 approximated global optimum을 얻을 수 있다. continuous optimization에서도 보조로 쓰일 수 있겠군...\n원래 anealing이라는 것은 금속이나 유리를 불에 달궜다가 천천히 식혀서 강화시키는 것을 말한다. 금속에 열을 가하면 원자가 막 자유롭게 돌아다니다가 천천히 식는 동안에 minimum-energy state로 구조가 변경이 된다. 반대로 금속을 빠르게 냉각하면 금속이 비정질금속(amorphous metal)이라고 불리는 다른 더 높은 에너지 state로 재 결정화(recrystallized)된다.\n이건 그냥 맞는지 아닌지 잘 모르겠는 내 해석인데, 금속에 열을 가한다는 것은 design variable을 사방에 흩트려 놓았다가 온도를 천천히 낮추면서 minimum state 향해 가는게 optimum solution으로 다가가는 거라고 보면 그 확률을 조절하는 건거 같다.\n시스템이 특정 에너지와 온도로 어떤 상태에 있을 확률을 분포로 나타낸 것을 Boltzmann distribution (Gibb distribution이라고도 함) 이라고 하며 아래와 같은 관계를 갖는다.\n$$P(e) \\propto \\exp \\left( \\frac{-e}{k_B T} \\right)$$ 여기서 $e$는 에너지 레벨이고 T는 온도, $k_B$는 Boltzmann 상수이다. $f(x)=\\exp{-\\frac{1}{x}}$의 그래프가 아래와 같으므로... 온도 T가 감소하면 높은 에너지 state로 있을 확률이 감소한다. 하지만 절대 0이 되지 않는데 이게 T에 해당하는 parameter가 감소하고 local minimum에 가까워 지더라도 hight envergy level로 점프한다는 거는 design variable의 다양성이 커져서 local mimimum에 빠지지 않게 만들어 준다는 듯 Metropolis–Hastings algorithm 이라는 것이 있는데 probability distribution에서 a sequence of random samples을 구하는 방법이다. 이 알고리즘을 적용하여서 우리가 가지고 있는 probability distribution에서 design variable set을 얻는다. 여기서 P가 위에서 말한 atom의 Boltzmann distribution에 해당하는 건데 우리는 Boltzmann 상수 같은 건 필요없으니까 제외하고 energy level $e$를 objective function value로 생각하면 된다.\n","link":"https://dahjeong.github.io/kr/optimization/discrete/","section":"optimization","tags":null,"title":"Discrete Optimization"},{"body":"","link":"https://dahjeong.github.io/kr/categories/constraints/","section":"categories","tags":null,"title":"Constraints"},{"body":"Penalty method 제약조건이 있는 Constrained optimization을 간단하게 제약조건이 없는 unconstrained optimization으로 변환할 수 있는 방법이다. penalty parameter 설정에 의해서 true optimum에 수렴하지 않을 경우가 있어서 gradient based optimization에서는 더이상 사용되지 않는다. graient free method에서 사용되기도 하고, constrained optimization을 이해하는데 도움이 되기 때문에 살펴보자. 일단 constrained optimization problem의 formulation은 아래와 같다. $$\\begin{aligned} \\text{minimize} \\quad \u0026amp; f(x) \u0026amp; \\newline \\text{by varying} \\quad \u0026amp; x_i \u0026amp; i=1,...,n_x \\newline \\text{subject to} \\quad \u0026amp; g_j(x) \\leq 0 \u0026amp; j=1,...,n_g \\newline \u0026amp; h_l(x) = 0 \u0026amp; l=1,...,n_h \\newline \u0026amp; \\underline{x_i} \\leq x_i \u0026lt;\\overline{x_i} \u0026amp; i=1,...,n_x \\end{aligned}$$\n여기서 equality constraint $h_l(x)$ 와 inequality constraint $g_j(x)$에 penalty method를 적용하면 objective function은 다음과 같이 변화한다. $$\\hat{f}(x;\\pi_{\\alpha}, \\pi_{\\beta}) = f(x) + \\pi_{\\alpha} \\sum_{l=1}^{n_h} h_l(x) +\\pi_{\\beta} \\sum_{j=1}^{n_g} \\max{[0, g_j(x)]}$$ 이 말은 즉슨, $h_l$이 0이 아니면 $h_l$값과 penalty parameter $\\pi_{\\alpha}$의 곱이 objective function에 더해져서 objective function 값을 커지한다는 것이다. 또한 $g_j$가 0 보다 크게 되면 max function에서 $g_j(x)$ 값이 반환되어 penalty parameter $\\pi_{\\beta}$와 곱해져서 objective funciont 값을 크게한다. 따라서 제약조건들을 만족하지 않으면 objective function evaluation에서 penalty를 갖게되어서 minimum solution과 멀어지게 된다.\n직관적이고 쉽다. 근데 여기서 문제가 이 penalty parameter를 어떻게 설정하냐 인다. 아래의 그림에서 $\\mu$로 표기되어 있는 penalty parameter는 클수록 true optimum을 찾을 가능성이 커지는데 너무 크게되면 argument $x$의 작은 변화에도 아주 민감하게 되어서 또 최적해를 찾기가 어려워 진다. 이게, argumented Lagrangian 이랑 비슷하게 생겼는데 다른 점은, penalty parameter에 상응하는 argumented Lagrangian의 Lagrangian은 해를 찾으면서 같이 풀리기 때문에 정할 필요가 없다는 것이다.\n","link":"https://dahjeong.github.io/kr/optimization/penalty/","section":"optimization","tags":null,"title":"Penalty Methods"},{"body":"","link":"https://dahjeong.github.io/kr/categories/autobiography/","section":"categories","tags":null,"title":"Autobiography"},{"body":"[사람사는세상 노무현재단, 유시민 공편]\n2007년 1월경에 유럽에서 돌아오는 날에 어머니께서\n","link":"https://dahjeong.github.io/kr/books/destiny/","section":"books","tags":null,"title":"운명이다 - 노무현 자서전"},{"body":"","link":"https://dahjeong.github.io/kr/categories/manga/","section":"categories","tags":null,"title":"Manga"},{"body":"[글: 오바 츠구미, 그림: 오바타 타케시]\n칼 마르크스는 그의 책에서 “당신의 ‘존재’가 희미하면 희미할수록, 그리고 당신이 당신의 생명을 적게 표현하면 표현 할수록, 당신은 그만큼 더 ‘소유’하게 되고, 당신의 생명은 그만큼 더 소외된다.”라고 했다.\n나이가 들면서 점점 더 삶에 대한 근원적 질문을 회피하게 된다. 자신의 존재에 대한 정답이 없는 질문들은 사춘기 때 자아정체성 확립이라는 명목으로 표면적인 정리가 끝난 듯 해 보이지만 그것조차 제 때, 제대로 이루지 못한 사람들이 태반이다. 또한 인간이 더욱 더 많은 것을 소유하게 되고 그 소유에 몰두할수록 어떤 것이 정의이며 생명인지를 잃어가게 된다. 나 역시 잊고 지내던 정의 실현의 방법론적 타당성이나 소유에 몰두한 삶에 대해 얼마 전 접하게 된 데스노트라는 만화 속 두 인물을 보며 다시 생각해 보는 기회가 되었다.\n데스노트는 오바 츠구미 글, 오바타 타케시 그림의 총 12권으로 구성된 만화책이다. 2004년 일본에서 첫 단행본을 출간하였고 올해 2편의 영화로 제작되어 일본과 한국 외 홍콩, 대만 등의 아시아 전역에서 제작비의 4배인 800억을 벌어들이는 놀라운 흥행을 기록하였다. 데스노트의 줄거리는 대강 이렇다. 사신계에 따분함을 느낀 사신 류크는 사람의 얼굴을 떠올리며 이름을 적는 것만으로도 그 사람을 죽일 수 있는 데스노트를 인간계에 떨어뜨린다. 그 노트는 일본의 한 천재 소년 라이토의 손에 들어간다. 라이토는 이 노트를 이용해서 범죄자들을 죽이고 이상적 사회를 만드는 것을 꿈꾼다. 이에 명탐정 L은 그런 라이토를 막으려고 한다는 서로 다른 정의를 내세운 두 명의 천재의 두뇌싸움을 그린 만화 이다.\n라이토는 범죄 없는 이상세계를 만든다는 명목아래 수많은 범죄자들을 죽음으로 심판한다. 그리고 그 세계의 신이 되는 것은 자신 밖에 없다고 늘 스스로 되새긴다. 또한 작가는 실재 데스노트가 다른 사람의 소유가 되었을 때 그들이 그것을 단순히 개인의 이익을 위해서 쓰는 것을 보여주며 라이토의 심판이 법과 윤리를 떠나 인간의 기본적 소양 안에서 옹호를 받을 만한 여지를 충분히 지닌다고 이야기한다. 이것이 데스노트를 통해 우리가 얻게 되는 하나의 논란이다. 과연 정당한 절차를 벗어난 행위가 결과만을 통해 우리의 동감 살 수 있는가, 없는가의 윤리적 판단이 이 만화의 전반적으로 자리잡고 있다.\n인간이 인간을 심판하는 행위는 고대사회로부터 내려온 사회적 규칙에 의해 실행되는 하나의 행위임에 틀림없다. 법과 규칙이라는 언약적인 사회적 과정을 통해 인증되지 않는 응징은 과연 합당한 정의인가라는 논란은 사실 어떤 측면에서 보느냐에 따라 옳고 그름의 양분적 가치를 지닐 수 있다. 작가는 서로 다른 이 두 가지 가치 견해를 모두 지지하며 여러 주변 인물들을 통해 밝히고 있다. 또 하나 이 작품이 더욱 흥미로운 것은 그 것이 단순히 논란의 여지가 되는 산물에서 멈추는 것이 아니라 하나의 권력 형태로 확장된다는 것이다.\n전계의 후반부로 갈수록 자신의 정의에 갖힌 라이토는 자아를 잃고 자신의 이상에 반하는 세력을 거의 파괴하기에 이르게 된다. 이 파괴로 인해 라이토는 마음의 완전함을 느껴야 하지만 불안과 고립감을 더 키우게 되며 결국 노트에 의존한 자아만이 커져가며 자신의 쫒는 세력을 파괴하는데에만 광적으로 집착한다. 결말에서 작가는 표면적으로는 라이토를 죽임으로써 라이토의 정의실현 방법을 부정하는 것처럼 보이지만 그 안을 드려다 보면 실현 방법 자체의 가치 판단은 독자에게 맡겨 둔 체로 에리히 프롬이 언급한 권위주의로 도피에 의한 라이토의 자아 소멸을 보여주며 이야기를 마무리한다.\n정리하면, 노트의 절대적 권한에 의존하여 자신의 자아를 그 권한에 융합시키고 소멸한 라이토는 이미 우리 사회에서 선행된 가치판단에 의존해 자신의 의지를 맡기는 우리를 비추는 거울이라 볼 수 있다. 결국 이 만화 처음부터 끝까지 제기하고 있는 문제, 비윤리적 과정을 통해 이루어 낸 이상세계의 옳고 그름의 판단, 조차 우리는 스스로의 견해를 배재하고 사회적 통념에 의해 조종되고 있다는 것을 알려준다. 우리의 생각과 행동은 실제로 우리 자신의 것이 아니라, 외부로부터 암시된 어떤 것이 되는 것이다. 그렇다면 자신은 어떤 정의를 지지하겠는가?\n","link":"https://dahjeong.github.io/kr/books/dath-note/","section":"books","tags":null,"title":"데스노트"},{"body":"","link":"https://dahjeong.github.io/kr/categories/novel/","section":"categories","tags":null,"title":"Novel"},{"body":"[요나스 요나손]\n소설책이지만 재미있는 이야기 역사서 같은 느낌이었다. 옛날에 할아버지/할머니 혹은 엄마/아빠가 잠자리에 들기 전에 지어내서 들려주는 현실과 교묘하게 연결되는 이상한 이야기랑 비슷해서 어릴적 생각이 나면서 정말 재미있게 읽었다. 실제 역사에서 일어났던 중요한 사건들의 배후에 이 역사에 기록되지 않은 100세 노인, 알란 칼손 할아버지가 있고 이 이야기들이 너무 기가 막히게 잘 연결되어 있어서 굉장한 흡입력이 있었다.\n이야기는 100살 생일을 하루 앞둔 100세 노인이 요양원 창문을 넘어 도망치면서 시작된다. 이 할아버지는 어디론가에 떠나기 위해서 버스터미널에 가고 거기서 화장실이 급한 한 젊은 갱을 만난다. 이 버릇없는 청년이 할아버지에게 트렁크를 잠시 부탁하였고 그 사이에 원하는 버스가 오자 이 할아버지는 트렁크를 가지고 버스에 오른다. 그 트렁크에는 어마어마한 금액의 돈이 들어 있었기 때문에 그 트렁크를 노인에게 맡긴 젊은 갱과 그 갱이 속해져 있는 갱단, 실종된 할아버지와 갱단을 쫒는 형사와 검사, 할아버지가 이동하면서 만나게되는 사람들의 이야기가 현재 시점에서 풀어진다.\n그 중간 중간에 이 100세 할아버지가 스웨덴의 한 시골의 평범한 가정에서 태어나서부터 100살까지 살아낸 이야기를 들려주는데 개인적으로 이 이야기가 너무 재미 있었다. 미국과 러시아의 핵폭탄 개발에 큰 역할을 하게된 이야기나 북한에서 김일성을 만나는 등, 거짓말같은 엄청난 일들이 그의 인생에서 벌어지지만 역사서에는 기록되지 않는 사람, 기억되지 않는 사람의 이야기를 작가가 들려주는데 실제로 역사의 뒷이야기를 듣는 것처럼 정합성이 있고 흥미진진하다.\n소설책을 읽을 때는, 물론 가상의 인물이긴 하지만, 한 사람의 인생을 자세히 들여다보면 정말 다채로운 이야기들이 숨어 있을 수 있구나. 라는 생각이 든다. 이 할아버지처럼 여러 사건이 있을 수도 있지만 어떤 경우에는 큰 사건이 없더라도 심리적인 굴곡을 크게 겪게 될 수도 있다. 그래서 소설책을 읽다보면 인간에 대한 연민이 생긴다.\n","link":"https://dahjeong.github.io/kr/books/old-man/","section":"books","tags":null,"title":"창문 넘어 도망친 100세 노인"},{"body":"Complex step은 수치 미분값을 구하는 방법 중에 하나다. finite differencing을 유도할 때 small step $h$으로 real number가 아니라 imaginary로 취하고 Taylor expansion을 적용하면 아래와 같다. $$f(x+ih) = f(x) + ihf'(x) - \\frac{h^2}{2}f''(x)-\\frac{ih^3}{3!}f'''(x)+\\cdots$$\n여기서 imaginary part만 모아서 보자. $$\\text{Imag}[f(x+ih)] = hf'(x) - \\frac{h^3}{3!}f'''(x)+\\cdots$$\n위의 방정식을 $f'(x)$로 정리하면 아래와 같다. $$f'(x) = \\frac{\\text{Imag}[f(x+ih)]}{h} + O(h^2)$$\n앞에서 finite differencing에서는 step의 크기가 줄어들면, analytic solution과 비교하였을 때 derivative 값의 오차가 줄어들다가 어느 순간이되면 numerical error로 인해서 (subtraction에 의한 significant number의 문제) step이 줄어들어도 error가 커지는 현상이 발견된다. complex step 방법도 step $h$를 이용하지만 finite differencing과 같은 문제가 발생하지 않고 machine precision까지의 정확도가 보장된다. (아래 그림 참고)\n변수의 갯수가 늘어나면 계산 횟수가 늘어나는 것은 finite differencing과 같다. 오차의 order를 생각하면 central differencing 이랑 비슷하다. ","link":"https://dahjeong.github.io/kr/optimization/complex-step/","section":"optimization","tags":null,"title":"Complex Step"},{"body":"","link":"https://dahjeong.github.io/kr/categories/derivative/","section":"categories","tags":null,"title":"Derivative"},{"body":"수치적으로 미분값 구하는 방법은 4가지가 있는데 1) symbolic derivative 2) finite differencing 3)complex step method 4) automatic differenciation 이다. 그 중에서 가장 간단하게 자주 쓰이는 방법이 finite differencing 이다. 먼저 symbolic derivative는 함수의 analytic한 derivative를 찾는 방법이다. 예를 들어서 $f=\\sin(x)$의 경우에 symbolic derivative는 $f=\\cos(x)$이다. 그런데 이 방법은 implicit equation의 경우에 매우 비효율적인 연산이 되거나 계산 자체가 어렵다. 따라서 모든 함수에 symbolic derivative를 적용할 수가 없다.\n여기서 잠깐 implicit equation에 대해서 좀 더 자세히 알아보자. implicit equation이란 $f(x, y) = y$ 처럼 equation 내부에도 y가 있는 equation을 말한다. 내가 다루는 대부분의 equation이 이렇게 coupled relationship의 implicit equation 이다. implicit equation을 계산하는 방법은 예를 들어, $f=\\sin(x+f)$ 의 경우에 모든 x에서 이 관계가 성립해야 하므로 $f$ 를 guess 하고 새로운 $f$를 얻는 연산을 f가 수렴할 때까지 반복한다.\nfinite differencing은 symbolic derivative와는 다르게 function이 어떤 형태이건 상관없다. black box여도 된다. finite differencing은 Taylor expansion에서 아래와 같이 유도된다. $$f(x+h) = f(x)+hf'(x) + \\frac{h^2}{2}f''(x) + \\cdots$$ 2nd order term을 포함해서 이후의 모든 terms를 무시하고 $f'(x)$에 대해서 정리하면 아래와 같다. $$f'(x) \\approx \\frac{f(x+h)-f(x)}{h} + O(h)$$ 여기 high order terms O(h)만큼의 error가 생기는데 central differencing이라고 이를 개선한 방법도 있다. $$\\begin{aligned} f(x+h) \u0026amp;= f(x) + h \\frac{\\partial f}{\\partial x} + \\frac{h^2}{2}\\frac{\\partial ^2 f}{\\partial x^2} + \\cdots \\newline f(x-h) \u0026amp;= f(x) - h\\frac{\\partial f}{\\partial x} + \\frac{h^2}{2}\\frac{\\partial ^2 f}{\\partial x^2} - \\cdots \\end{aligned}$$ 위의 두 식을 빼면 2nd order term은 없어지지만 accuracy는 앞에서 언급한 forward finite differencing에 비해서 개선된다. 따라서 정리하면 아래와 같다. $$\\frac{\\partial f}{\\partial x} = \\frac{f(x+h)-f(x-h)}{2h} + O(h^2)$$ 근데 the number of design variables 변수의 수가 너무 많아지면 연산의 수도 늘어나서 이게 finite differncing의 단점이다. 그리고 또 하나의 단점이 step size h에 의해서 order of accuracy가 결정된다는 점이다. step size가 작아진다고 에러가 줄어드는 것이 아니라 에러가 줄어들다가 어떤 값 이하에서는 수치적으로 어떤 digit을 잃어버리기 때문에 에러가 커지는 경우가 생긴다. 그래서 accuracy를 향상시키는데 한계가 있다.\n","link":"https://dahjeong.github.io/kr/optimization/finite-differemcing/","section":"optimization","tags":null,"title":"Finite Differencing"},{"body":"$$\\underset{x}{\\text{minimize}} f(x)$$ 위의 식과 같이 constraint가 없는 최적화 문제에 problem domain이 모든 영역에서 differentiable하면 (미분가능, 이건 연속이랑 다른 개념이라는 걸 고딩 때 배우지) 해당 함수의 gradient, $\\nabla f = 0$ 지점이 함수의 극 값, 즉 maximum이나 minimum이 된다. 그래서 최적화 문제 풀 때 $\\nabla f(x) = 0$ 의 방정식을 푸는데 (이 방정식을 만족시키는 x를 구한다) 이 과정에서 line search가 나온다.\n수치해석적으로 $x$를 적절히 이동시키면서 위의 방정식이 어떤 tolerance $\\epsilon$ 내에서 만족되면 연산을 정지한다.\n1k=0 2while || $\\nabla f ||_{\\infty} \\geq \\epsilon$ do 3 search direction $p_k$ 결정 4 step length $\\alpha_k$ 결정 5 $x_{k+1} = x_k+\\alpha_k p_k$ 6 $k=k+1$ 7end while 근데 그러면 $p_k$ 랑 $\\alpha_k$ 는 어떻게 결정하면 될까? 일단 subproblem으로 다른 변수들은 다 fix한 상태에서 $\\alpha$를 구하는 것을 먼저 생각해 보자. $k+1$ 번째 $x$는 $x_{k+1} = x_k + \\alpha p_k$ 이므로 이를 함수 $f$에 대입하면 $f(x_{k+1}) = f(x_k + \\alpha p_k) = \\phi(\\alpha)$ 이고, 함수 $\\phi$를 step length $\\alpha$에 의한 함수로 정의하자. 이 함수 값은 $\\alpha = 0$ 일때 $\\phi(0) = f(x_k)$ 이므로 (현재 우리가 알고 있는 값) 여기서 $\\phi'(0)$ 보다 좀 더 flat한 직선을 그었을 때 $\\phi(\\alpha)$ 값들이 이 직선보다 작아야 한다. (여기서 $\\phi'(0) \u0026lt; 0$)\n$$\\phi(\\alpha) \\leq \\phi(0)+\\mu_1 \\alpha \\phi'(0) = f(x_k)+ \\mu_1 \\alpha \\nabla f(x_k)p_k$$ $$\\phi'(\\alpha) = \\nabla f(x_k+ \\alpha p_k)p_k$$ $$\\phi'(0) = \\nabla f(x_k)p_k$$\n이런 $\\alpha$를 찾기 위해서 아래의 알고리즘 절차를 거친다.\n1set $\\alpha_{\\text{init}} \u0026gt; 0$, 2 $0\u0026lt;\\mu_1 \u0026lt;1$, 3 $0\u0026lt;\\rho \u0026lt;1$ 4 $\\alpha = \\alpha_{\\text{init}}$ 5while $\\phi(\\alpha) \\geq \\phi(0)+\\mu_1 \\alpha \\phi\u0026#39;(0)$ do 6 $\\alpha = \\rho \\alpha$ 7end while 근데 거의 몇번의 iteration만 거치면 적당한 $\\alpha$를 빨리 찾는다. $\\phi'(\\alpha)$가 너무 steep하면 조건을 만족하는 alpha를 찾기가 힘들다. 이때 strong Wolfe conditions 이라는 것을 적용하여 vertical line처럼 아예 가파르게 되는 지점을 제외시킨다.\n$$|\\phi'(\\alpha)| \\leq \\mu_2 |\\phi'(0)| $$\n","link":"https://dahjeong.github.io/kr/optimization/line-search/","section":"optimization","tags":null,"title":"Line Search"},{"body":"","link":"https://dahjeong.github.io/kr/categories/root-finding/","section":"categories","tags":null,"title":"Root finding"},{"body":"Search Direction line search 할 때 어디로 line 그어서 어느 방향으로 이동할 지를 결정해서 one dimensional problem을 반복적으로 푸는 것이다. 오늘은 이 search direction을 어떻게 정하는지 알아 보자. Matines \u0026amp; Andrew 의 text book에서는 아래의 5가지 방법을 소개한다.\nSteepest Descent Conjugate Gradient Newton's Method Quasi-Newton Methods Limited-Memory Quasi-Newton Methods Steepest Descent Gradient가 빠르게 증가하는 반대 방향으로 search direction을 정하는 것이다. $$p = - \\nabla f$$ 또는 normalized를 이용하기도 함 $$p = - \\frac{\\nabla f}{||f||}$$ curvature가 방향에 따라 일정하면 빠르게 수렴한다. 근데 실제 문제에서 curvature가 방향에 따라 일정한 경우가 거의 없으므로 대부분의 경우에서 steepest descent는 비효율적이다.\nConjugate Gradient 처음 정한 search direction의 orthogonal 한 방향으로 search direction을 정하는 것. $$p^{(k)}=-\\nabla f^{(k)} + \\beta p^{(k-1)}$$ where $$\\beta^{k} = \\frac{||\\nabla f^{(k)}||^{2}}{||\\nabla f^{(k-1)}||^{2}}$$ 이렇게 하면 어떤 특정한 문제를 풀 때에는 Steepest Descent보다 빠르게 수렴한다.\nNewton's Method Curvature information에 영향을 많이 받는데 그러면 이걸 아예 문제 풀이에 활용하는 방법은 없을까? 해서 나온 것이 Newton's method이다. Taylor expansion에서 2nd order term까지 활용해 보자. 함수 $f(x)$ 이 있는데, $x$에서 작은 $s$만큼 떨어진 곳의 함수 값 f(x+s)는 Taylor approximation에 의해서 아래와 같다. $$f(x+s) = f(x)+\\nabla f^{T}(x)s+\\frac{1}{2}s^{T}H(x)s + \\cdots$$ 이것의 derivative가 '0' 가 되는 지점이 극점이다. $$\\frac{d[f(x+s)]}{ds} = \\nabla f + Hs = 0 $$ 정리하면 $$Hs = -\\nabla f$$ 따라서 small step $s$는 아래와 같다. $$s=-H^{-1} \\nabla f$$ line search의 step size $\\alpha$, search direction $p$일 때 다음 step $s=\\alpha p$ 인 것을 떠올려 보자! 여기 $s=-H^{-1} \\nabla f$ 에서 direction이 gradient descent의 $p=-\\nabla f$ 인 상태에서 step size가 inverse Hessian 인 것과 같다고 볼 수 있다.\n여기에! 뭔 문제가 3가지 있다.\nHessian이 positive definite가 아닐 수 있다. 그러면 이 방법으로 찾아지는 search direction이 descent direction이 아닐 수도 있어서 mininum을 찾을 수 없을 수도 있다. 이걸 해결하기 위해서 Hessian을 modify해서 positive definite이 되게 하는 방법이 있다. 그러면 descent direction이면서 approximate curvature를 찾아낼 수 있다. 예측한 새로운 guess가 더 안 좋을 수 있다. 그럼 backtracking을 해서 다시 찾아볼 수 있다. Hessian을 계산하는게 어렵거나 비싸다. 이걸 해결하기 위해서 quasi-Newton methods가 나옴 Quasi-Newton Methods 앞에서 언급한 것과 같이 Newton's method에서 Hessian을 계산하는게 어렵기 때문에 quasi-Newton methods로 Hessian을 approximation 한다. 이 방법 중에 가장 많이 쓰이는 것이\nBroyden–Fletcher–Goldfarb–Shanno (BFGS) 이다. BFGS는 Davidon–Fletcher–Powell (DFP)에서 출발하였다. 일단 둘 다, gradient를 구하고 난 다음에 Secant rule을 이용해서 Hessian을 approximate한다. 따라서 approximated Hessian $B$는 다음과 같다. $$B^{(k+1)} = \\frac{\\nabla f^{(k+1)} - \\nabla f^{(k)}}{x^{(k+1)}-x^{(k)}}$$\nDFP의 경우에 무한으로 존재하는 Hessian 중에서 이전 iteration의 Hessian $B^{(k)}$과 현재 Hessian $B^{(k+1)}$의 차이가 가장 적은 Hessian을 찾아서 이것을 approximated Hessian으로 쓰는 방법이다. 따라서 minimum 값을 구하기 위한 optimization 문제를 풀어줘야 한다. 그것을 적용하는 과정에서 Newton's method의 step $p = -H^{-1} \\nabla f \\approx -B^{-1} \\nabla f$를 근사화하는데 여기서 approximated Hessian의 inverse 값 $B^{-1}$을 $V$로 두고 바로 $V$를 구하는 방법이 BFGS 이다. 따라서 Newton's method의 step $p \\approx -V\\nabla f$가 되고 approximated inverse Hessian $V$ 를 구하기 위해서 아래와 같은 연산이 수행된다. $$\\begin{aligned} \\underset {V^{(k+1)}}{\\text{minimize}} \u0026amp;\\quad ||V^{(k+1)}-V^{(k)}|| \\newline \\text{subject to} \u0026amp; \\quad V^{(k+1)}(\\nabla f^{(k+1)}-\\nabla f^{(k)}) = x^{(k+1)} - x^{(k)} \\newline \u0026amp; \\quad V^{(k+1)} = {V^{(k+1)}}^{T} \\end{aligned}$$\n$V$는 positive semi-definite matrix를 이어야하므로 initial 값으로 identity matrix를 이용한다.\nLimited-Memory Quasi-Newton Methods Quasi-Newton Methods에서 Hessian matrix를 계속 memory에 저장하고 있어야 하는데 변수의 수가 너무 많아서 Hessian matrix가 너무 크게 되고 memory 용량이 적어서 다 저장하지 못하는 경우에 Limited-memory quasi-Newton methods가 쓰인다. Limited-memory quasi-Newton methods의 대표적인 방법이 Limited-memory BFGS (L-BFGS) 이다. 우리는 Hessian 값 자체가 필요한 것이 아니라 Newton's method의 step 으로 $p=-H^{-1} \\nabla f$ 값이 필요한 것이다. 따라서 L-BFGS 방법은 approximated inverse matrix $V$와 $\\nabla f$의 product 값을 한번에 구해서 matrix vector product하는 계산도 줄이고 Hessian matrix 저장하는 공간도 줄인다.\n","link":"https://dahjeong.github.io/kr/optimization/search-direction/","section":"optimization","tags":null,"title":"Search Direction"},{"body":"Trust-Region Methods Line search에서는 방향과 step을 정해서 이동하면서 minimum인지 아닌지 확인하는 반면에 trust region methods에서는 radius를 정해서 그 안에서 approximated function의 minimum을 찾고 그 minimum으로 이동하여 다시 더 큰 radius의 region을 그리고 그 안에서 minimum을 찾는 행위를 반복한다. 최적값으로 수렴하기 전에는 항상 boundary에서 minimum 값을 갖지만 수렴하게되면 radius를 더 크게 해도 boundary 내의 특정 위치를 minimum 값으로 얻고 계산을 반복해도 minimum 값이 바뀌지 않는다. 이를 정리하면 trust-region methods는 아래와 같은 과정으로 진행되고 3번에서 1번으로 반복된다.\n현재 위치에서 approximation model을 만든다. trust-region 내에서 모델을 최소화 한다. 새로운 위치로 이동하고 trust-region의 size를 조절한다. 1번에서 말하는 approximation model이 quadratic form 일때 trust-region을 수학적으로 쓰면 아래와 같은 subproblem을 푸는 것과 같다.\n$$\\begin{aligned} \\underset{s}{\\text{minimize}} \\quad \u0026amp; \\tilde{f}(s) = f_{k} + \\nabla f_{k}^{T}s + \\frac{1}{2} s^{T} \\tilde{H}_{k}s \\newline \\text{subject to} \\quad \u0026amp; ||s||_2 \\leq \\Delta_k \\end{aligned}$$\n여기서 $\\tilde{H}_k$ 는 approximated Hessian 이고 variable $s$는 $s=-\\tilde{H}(k)^{-1} \\nabla f_k$이다. $\\Delta$ 는 trust region의 크기이며 아래의 matric $r$에 의해서 업데이트된다.\n$$r=\\frac{\\text{actual decrease}}{\\text{expected decrease}}=\\frac{f(x)-f(x+s)}{\\tilde{f}(0)-\\tilde{f}(s)}$$\n여기서 $r\\approx1$이면 우리의 approximated model $\\tilde{f}$이 실제와 잘 매칭된다는 것이다. 근데 $r\u0026gt;1$이면 expected 보다 actual decrease가 더 크다는 거니까 trust region이 더 커져도 된다. $r\u0026lt;0$이면 trust resion이 너무 크다는 것! 그래서 아래와 같은 알고리즘으로 움직인다.\n1 if r ≤ 0.05: 2 \\Delta^{(k+1)} = \\Delta^{(k)}/4 3 s^{(k)} \\quad = 0 4 elif r \\geq 0.9 and ||s^{(k)}||=\\Delta^{(k)}: #(boundary에서 minimum이 나오면) 5 \\Delta^{(k+1)}=\\min(2 \\Delta, \\Delta_{\\max}) #(maximum radius보다 작으면 radius를 2배로 키운다.) 6 else 7 $\\Delta^{(k+1)}=\\Delta^{(k)}$ Trust-region method의 특징은 아래와 같다.\nTrust-region은 Hessian에 민감하기 때문에 정확한 Hessian을 추정하는 것이 중요하다. Trust-region이 line search에 비해서 iteration 수가 적지만 각각의 iteration 계산에 드는 비용이 더 비싸다. 대부분의 optimization 문제들이 변수들의 scaling에 민감하긴 하지만, Trust-region은 특히 더 scaling에 민감하다. ","link":"https://dahjeong.github.io/kr/optimization/trust-region/","section":"optimization","tags":null,"title":"Trust-Region Methods"},{"body":"","link":"https://dahjeong.github.io/kr/aircraft/","section":"aircraft","tags":null,"title":""},{"body":"","link":"https://dahjeong.github.io/kr/categories/aircraft-design/","section":"categories","tags":null,"title":"Aircraft Design"},{"body":"","link":"https://dahjeong.github.io/kr/tags/drag/","section":"tags","tags":null,"title":"drag"},{"body":"","link":"https://dahjeong.github.io/kr/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"캠버항력은 에어포일의 캠버와 날개의 비틀림 각에 의해서 유발되는 항력이며 아래와 같이 표현할 수 있다.\n$$C_{D_{camber}} = \\frac{e}{1-e} K (\\Delta C_{L}^{2})$$\n여기서 e는 스팬 효율계수이며 K는 유도항력 비례상수, $\\Delta C_{L}$은 캠버에 의한 양력 증가분이며 아래와 같다.\n$$\\Delta C_{L} = \\left( 1-\\frac{1}{\\pi \\cdot A \\cdot K} \\right) C_{Lopt}$$\n여기서 $C_{Lopt}$는 일반적인 에어포일의 경우에 다음과 같다.\n$$C_{Lopt} = 0.8505 \\left(1-e^{-18.728(f/c)}\\right)$$\n$f/c$는 최대캠버와 날개시위의 비이다.\n초 임계 에어포일의 경우에 $C_{Lopt}$는 아래와 같다.\n$$C_{Lopt} = 0.5195 (C_{Ld})^{0.75}$$\n여기서 $C_{Ld}$는 설계 양력계수이다.\n만일 $e=1.0$이라면 아래와 같은 경험식을 사용하여 캠버항력을 구한다.\n$$C_{D_{camber}} = 0.7 (\\Delta C_{L})^{2} \\frac{S_{exp}}{S_{ref}}$$\n","link":"https://dahjeong.github.io/kr/aircraft/camber-drag/","section":"aircraft","tags":["drag"],"title":"캠버 항력 (Camber Drag)"},{"body":"유도항력은 날개에서 양력이 발생하면 필연적으로 발생하는 날개 끝 와류에 의한 항력으로 양력계수의 제곱에 비례한다.\n$$C_{D_{i}} = KC^{2}_{L}$$\n여기서 비례상수 K는 Oswald 스팬 효율계수법(Oswald Span Efficiency Method)과 앞전 흡입법(Leading Edge Suction Method) 두 가지 방법으로 구할 수 있다.\nOswald 스팬 효율계산법 아음속 항공기의 경우, 타원형 양력분포를 갖는 날개와 비교한 효율(e)에 의해서 K 값이 결정된다.\n$$K=\\frac{1}{\\pi e A}$$\n여기서 스팬효율계수 e는 경험식에 의해서 아래와 같이 결정된다.\n$\\begin{aligned} e = 1.78(1-0.045A^{0.68})-0.64, (\\Lambda_{LE} \\le 30^{\\circ}) \\end{aligned}$ $\\begin{aligned} e = 4.61(1-0.045A^{0.68})(\\cos \\Lambda_{LE})^{0.15}-3.1, (\\Lambda_{LE} \\le 30^{\\circ}) \\end{aligned}$\n초음속 항공기의 경우, 마하수에 따른 K값을 구하는 경험식은 아래와 같다.\n$$K = \\frac{A(M^{2}-1)}{4A\\sqrt{M^{2}-1}-2}\\cos \\Lambda_{L.E.}$$\n앞전 흡입법 Oswald 스팬 효율계산법은 받음각이나 비행 속도 영역의 변화에 따른 효과를 고려하지 못하는 단점이 있다. 이를 해결하기 위해서 앞전에서 흡입력을 고려해 주는 앞전 흡입법을 사용한다.\n$$K=(1-R)K_{0}+RK_{100}$$\n여기서 인자 R은 앞전 흡입계수(Leading Edge Suction Parameter)라고 하며 흡입력에 영향을 주는 인자인다. 앞전 반경이 큰 아음속 날개의 경우 R의 변화가 크지 않아 Oswald 스팬 효율계산법과 유사한 값을 얻는다. 이에 반해 얇은 두께 비와 후퇴각을 가지는 초음속 항공기의 경우에는 아래 그림을 통해 R을 구한다.\n","link":"https://dahjeong.github.io/kr/aircraft/induced-drag/","section":"aircraft","tags":["drag"],"title":"유도항력 (Induced Drag)"},{"body":"유해항력은 양력과 독립적으로 발생하는 항력이며 마찰항력(frictio Drag), 형상항력(Form Drag), 압력항력(Pressure Drag), 간섭항력(Interference Drag) 또는 조파항력(Wave Drag) 등이 이에 해당한다.\n$$C_{D_{p}}=\\Sigma(C_{f_{c}} \\cdot FF_{c} \\cdot Q_{c} \\cdot S_{wet_{c}})\\frac{1}{S_{ref}} + C_{D_{wave}} + C_{D_{base}} + C_{D_{misc}}$$\n여기서 $C_{f}$는 평판의 마찰항력계수(Flat Plate Skin Friction coeffient), FF는 형상 계수(Form Factor), Q는 간섭계수(Interference Factor), $C_{D_{wave}}$는 조파항력계수, $C_{D_{base}}$는 기저항력계수, $C_{D_{misc}}$는 기타 항력계수, $S_{ref}$는 항공기의 기준 면적, $S_{wet}$는 항공기 구성품의 표피 면적 (Wetted area) 이며 아래 첨자 c는 구성 요소(Component)들을 의미한다.\n1. 마찰계수(Skin Friction coeffient) $$C_{f} = \\frac{0.455}{(\\log_{10}Re_{L})^{2.58}(1+0.144M^{2})^{0.65}}$$\n여기서 레이놀즈 수 $Re_{L}$ 는 아래와 같다.\n$$Re_{L}=Re \\cdot \\bar{L} \\cdot M$$\n이때 고도 1ft 당, 마하수 M=1에 대한 레이놀즈 수 Re는 다음과 같다.\n$$Re = 10^{6}\\exp\\left[\\ln(7.1)-(h/1000)^{\\frac{1.1}{4.6}}\\right],~0\u0026lt;h\\le 36,000\\text{ft}$$ $$Re = 10^{6}\\exp\\left[\\ln(2.3168)-(h/1000-36)^{\\frac{0.99}{19.97} }\\right],~h\u0026gt;36,000\\text{ft}$$\n그리고 $\\bar{L}$ 는 면적 평균 특성 길이(Area Weighted Characteristic Length)로 아래와 같이 정의된다.\n$$\\bar{L} = \\frac{\\Sigma(l_{c} \\cdot S_{wetc})}{\\Sigma S_{wetc}}$$\n여기서 $l_{c}$는 구성품의 특성길이이고 $S_{wet}$는 구성품의 표피 면적(Wetted Area) 그리고 아래 첨자 c는 구성 요소(Component)들을 의미한다.\n2. 형상계수(Form Factor) 2-1. 단면이 에어포일 형태인 날개, 꼬리날개, 스트러트 또는 파이런 등과 같이 유선형 물체에 대한 형상계수\n$$FF = \\left[ 1+ \\frac{0.6}{(x/c)_{t\\max}(t/c)+100(t/c)^{4}} \\right] \\left[ 1.34M^{0.18}(\\cos{\\Lambda_{m}})^{0.28} \\right]$$\n여기서 $(x/c)_{t\\max}$ 는 에어포일의 최대 두께 위치이다. 저속형 에어포일의 경우에 일반적으로 $(x/c)_{t\\max} \\approx 0.3$ 이고 고속형 에어포일의 경우에 $(x/c)_{t\\max} \\approx 0.5$ 정도이다. $\\Lambda_{m}$은 최대 두께 선의 후퇴각이다. 힌지로 연결된 Rudder와 Elevator가 있는 꼬리날개의 경우 꼬리날개면과 조종면 사이의 틈새로 인해 계산한 형상계수에서 10%정도가 더 추가된다.\n2-2. 동체와 유선형 캐노피에 대한 형상계수\n$$FF = 1+ \\frac{60}{f^{3}}+\\frac{f}{400}$$\n여기서 세장비(sharpness) f는 다음과 같다.\n$$f=\\frac{l}{d}=\\frac{l}{\\sqrt{(4/\\pi)\\cdot A_{max}}}$$\n여기서 $l$은 물체의 특성길이이고, $d$는 구성 요소의 지름으로 단면이 원이 아닌 경우에는 단면의 최대 넓이 $A_{max}$를 이용해서 구한다.\n2-3. 나셀 또는 유선형 외부 장착물에 대한 형상계수\n$$FF = 1 + \\frac{0.35}{f}$$\n2-4. 기관 흡입구와 동체 사이의 경계층 분리기에 대한 형상 계수\n$$FF = 1+(d/l) \\text{ for double wedge type}$$ $$FF = 1+(2d/l) \\text{ for single wedge type}$$\n3. 간섭계수(Interference Factor) 구성요소 간섭계수 $Q_{c}$ 정형되지 않은(unfilleted) 저익기 1.1~1.4 고익, 중익 및 정형된 저익기 1.0 수직꼬리날개 1.03 수평꼬리날개 1.08 V-형 꼬리날개 1.04 ~ 1.05 나셀 등 외부 장착물 직접 부착된 경우 1.5 장착거리가 지름보다 작을 경우 1.3 장착더리가 지름보다 클 경우 1.0 날개 끝 장착 1.25 4. 기저항력계수(Base Drag) 기저항력은 물체 뒤쪽에서 단면적의 급격한 감소 또는 불연속에의한 유동 분리 현상으로 발생되는 압력저항이다. 기저항력은 아음속에서 일정하게 유지되다가 천음속 영역에서 서서히 증가하고 다시 $M=1.0 \\sim 1.8$ 구간에서는 상대적으로 일정한 값을 가지며 $M=1.8$ 이상에서는 서서히 감소한다.\n$\\begin{aligned} C_{D_{base}} = (0.1+0.1222M^{8})\\frac{A_{base}}{S_{ref}} \\qquad \\text{ for } M \\le 1\\ \\end{aligned}$ $\\begin{aligned} C_{D_{base}} = 0.2222\\frac{A_{base}}{S_{ref}} \\quad \\qquad \\qquad \\qquad \\text{ for } 1.0\u0026lt;M\\le1.8\\ \\end{aligned}$ $\\begin{aligned} C_{D_{base}} = 1.42\\frac{A_{base}}{S_{ref}}/(3.15+M^{2}) \\qquad \\text{ for } M\\ge1.8 \\end{aligned}$\n여기서 $A_{base}$는 물체 뒤에 급격한 단면 변화 부분의 투영 단면적이다.\n5. 조파항력계수(Wave Drag) 조파항력은 초음속영역에서 항공기 주변의 충격파에 의해서 발생하는 일종의 압력 손실이다.\n일반적인 항공기의 경우에 Sears-Haack body 의 면적 분포를 가지고 있다.\n$$\\frac{r}{r_{max}} = \\left[ 1-\\left(\\frac{x}{l/2} \\right)^{2} \\right]^{0.75}$$\n여기서 $r$은 단면 반지름(the cross-section radius)이고 $l$은 물체의 전체 길이(longitudimal dimension)이다. 변수 $x$는 $-l/2\\le x \\le l/2$ 이다.\nSears-Haack body 분포를 따르는 항공기의 경우에 조파항력은 아래와 같다.\n$$C_{D_{wave}} = \\frac{1.5 \\pi}{S} \\left( \\frac{A_{max}}{l} \\right)^{2}$$\n또한 마하수가 1.2 이상($M\u0026gt;1.2$)인 경우의 조파항력은 다음과 같다.\n$$C_{D_{wave}}=\\frac{4.5\\pi}{S_{ref}}\\left( \\frac{A_{max}}{l} \\right)^{2}E_{WD}(0.74+0.37\\cos\\Lambda_{L.E.})\\left[1-0.3\\sqrt{M-M_{C_{D0_{max}}}} \\right]$$\n여기서 $S_{ref}$는 항공기 기준 면적, A_{max}는 물체의 최대 단면적 그리고 $E_{WD}$는 경험적 조파항력계수(Sears-Haack body)와 실제 면적 분포의 경우에 대한 비로 완전한 Sears-Haack body는 $E_{WD}=1.0$, 부드러운 면적분포를 갖는 항공기의 경우에 $E_{WD}=1.2$, 일반적인 초음속 항공기의 경우 $E_{WD}=1.4~2.0$, 울퉁불퉁한 면적분포를 갖는 초음속 항공기의 경우에 $E_{WD}=2.0~3.0$이다. 조파항력 최대 마하수 $M_{C_{D0_{max}}}$는 아래와 같다.\n$$M_{C_{D0_{max}}}=\\frac{1}{\\cos^{2}\\Lambda_{L.E.}}$$\n6. 기타항력계수(Miscellaneous Drag) 6-1. 착륙장치항력(Landing Gear Drag)\n$$C_{Dlanding-gear}=\\sum_{c} C_{DL_{c}} \\cdot \\frac{A_{landing-gear,c}}{S_{ref}}$$\n여기서 $A_{landing-gear,c}$는 착륙장치 부품의 전면 면적이고 착륙장치 항력계수 $C_{DL_{c}}$는 아래 표와 같다.\n착륙장치 항력계수($C_{DL_{c}}$) Regular wheel and tire 0.25 Second wheel and tire in tandom 0.15 Streamlined wheel and tire 0.18 Wheel and tire with fairing 0.13 Streamline strut ($1/6 \u0026lt; t/c \u0026lt; 1/3 $) 0.05 Round strut or wire 0.30 Flat spring gear leg 1.40 Fork, bogey, irregular fitting 1.0 ~ 1.4 6-2. 스피드브레이크항력(Speed Brake Drag)\n스피드브레이크에 의한 항력은 동체에 장착된 경우와 날개에 장착된 경우로 나뉜다.\n동체에 장착된 경우에 아래와 같이 계산한다.\n$$C_{D_{speed-brake}}=1.0\\times \\frac{A_{speed-brake}}{S_{ref}}$$\n날개에 장착된 경우(0.6 chord 위치)에는 다음과 같이 계산한다.\n$$C_{D_{speed-brake}}=1.6\\times \\frac{A_{speed-brake}}{S_{ref}}$$\n여기서 $$A_{speed-brake}$$는 스피드 브레이크 전면 면적이다.\n6-3. 플랩항력(Flap Drag)\n플랩에 의한 항력은 다음의 식으로 계산한다.\n$$C_{Dflap} = 0.0023 \\frac{\\text{flap span}}{\\text{wing span}}\\delta_{flap}$$\n6-4. 누출 및 거칠기 항력(Leakage and Protuberance Drag)\n압력이 높은 부분에서 항공기 틈새나 구멍을 통해서 항공기 내부로 공기가 유입되어 생기는 운동량 손싱, 또는 항공기 내부에서 압력이 낮은 항공기 외부로 공기 분출이 일어나 유동 흐름을 분리시켜 발생하는 항력을 누출항력이라고 한다.\n또한 항공기의 안테나, 전조등, 항공기 표면의 리벳이나 표면 자체 거칠기 또는 항공기 표면을 구성하는 평판 등의 부적절한 결합과 돌기에 의한 항력을 거칠기항력이라고 한다.\n제트수송기 및 폭격기 2~5% 프로펠러항공기 5~10% 현용전투기 10~15% 신개념전투기 5~10% 가변익항공기 위의 값에 3% 추가 ","link":"https://dahjeong.github.io/kr/aircraft/parasite-drag/","section":"aircraft","tags":["drag"],"title":"유해항력 (Parasite Drag)"},{"body":"","link":"https://dahjeong.github.io/kr/tags/lift/","section":"tags","tags":null,"title":"lift"},{"body":"무장, 보조 연료탱크 등의 외부 장착물이 없고 착륙장치 등이 접힌 상태에서 항공기 전체의 양력 곡선을 추정하는 방법은 다음과 같다.\n구하고자 하는 비행 조건에서 항공기의 양력곡선 기울기 $C_{L\\alpha}$를 구한다. 영 양력받음각, $\\alpha_{L=0}$을 추정한다. 보통 개념설계 단계에서는 에어포일의 영받음각을 전체 날개의 영받음각으로 간주한다. 양력곡선의 직선부분이 끝나는 받음각 $\\alpha^*$를 찾아서 $\\alpha_{L=0}$로부터 $\\alpha^{*}$까지 기울기 $C_{L\\alpha}$인 직선을 그린다. 최대 양력계수 $C_{L_{max}}$ 와 그때의 받음각 $\\alpha_{max}$를 구한다. 양력곡선의 직선 끝부분 $\\alpha^{*}$와 최대 양력계수에서의 받음각 $\\alpha_{max}$ 사이를 부드럽게 이어지도록 곡선을 그린다.\n","link":"https://dahjeong.github.io/kr/aircraft/total-lift-curve/","section":"aircraft","tags":["lift"],"title":"전체 양력 곡선 추정"},{"body":"안녕하세요~! 제 이름은 김다정(Dajung Kim)이고, 항공우주공학도(Aerospace Engineer)입니다. 이렇게 불리우고 싶습니다. 일단, 저에 대한 자세한 이력서는 여기(CV)에 있습니다. 지금은 홍콩과기대 (HKUST-The Hong Kong University of Science and Technology)에서 Postdoctoral researcher로 있습니다.\n학부 때 항공우주공학✈️🚀과 전자공학⚛을 복수전공했습니다. 항공우주공학과에서 석사를 마치고 항공기✈️ 만드는 국가연구소에서 시스템 엔지니어링 연구원으로 2년간 일했습니다. 이후에 배🚢 만드는 회사로 이직해서 4년 반동안 선박 조종, 운동시뮬레이션, 운항지원시스템에 대한 연구를 했습니다. 그리고는 기계공학과에서 소음과 연료소모를 최소화하는 항공기 경로 설계(다목적 최적화-multi objective optimizaion)로 박사 학위👩‍🎓를 했습니다.\n프로그래밍👩🏻‍💻 하는 것도 좋아하고 실험👩🏻‍🔧하는 것도 좋아합니다. 근데 사실, 이론 공부하는 걸 더 좋아합니다. 특히 물리(物理: 사물의 이치)학을 좋아하고 수학은 잘 못하지만 좋아는 합니다.\n만화책 (신일숙 작가님 팬) 이랑 웹툰 보는 걸 즐기고, 활자 중독자처럼 책을 보고, 영화 보는거 (이창동 감독님 좋아해요), (요즘은 팟캐스트로 바꼈지만) 라디오 듣는 것도 좋아하고 미술 작품 보는 거, 콘서트 가는 것도 좋아합니다. 그리고 내가 좋아하는 이 모든 것들에 대한 내 생각을 적어두는 것도 좋아합니다. 운동은 주로 혼자하는 걸 좋아하는데, 답답하면 혼자서 조깅을 자주하고 수영하는 거 좋아합니다.\n5~6살때부터 지금까지 꾸준히 피아노를 쳐 왔는데 잘 치진 못합니다. 중학교 3학년 때 엄마 몰래 수학 학원비로 드럼 학원을 다니고 고등학교 때부터 대학교 1학년까지는 밴드부 드러머였는데 이것도 지금은 잘 못 합니다. 그래도 음악은 장르를 가리지 않고 정말 좋아합니다.\n부산에서 태어나서 고등학교 졸업할 때까지 부산에서 살았고, 이후에 인천에서 4년 반, 대전에서 4년, 울산에서 4년 반, 그리고 서울에서 1년을 살았습니다. 지금(2022년 12월)은 홍콩에서 4년 반째 살고 있습니다.\n초등학교 때 엄마와 여동생과 같이 간 태국 여행을 시작으로 해서 고등학교 때 일본 홈스테이를 하고, 2006년 대학생 3학년을 마치고 영국에 어학연수가면서 런던에서 6개월 정도 살았고, 이후에 3개월 반동안 혼자서 유럽여행을 했습니다. 돈 벌고 나서는 후지산 등반도 하고, 인도 스리나가르(Srinagar)와 리시케시(Rishikesh)에서 요가와 명상을 짧게 배웠습니다. 프랑스 테제(Taizé)에서 묵언수행도 해보고, 또 특별한 거라며... 2018년도에 스페인 산티아고 길(Camino de Santiago) 600km를 걸었습니다. 현재까지 23개국(태국, 일본, 영국, 네덜란드, 벨기에, 프랑스, 스위스, 이탈리아, 산마리노, 크로아티아, 보스니아, 슬로바키아, 헝가리, 폴란드, 체코, 스페인, 중국, 인도, 싱가폴, 대만, 베트남, 그리스, 미국)을 여행했습니다.\n이런 말을 하면 부자집에서 태어난 거라고 생각할 수도 있지만, 그저 돈 벌어서 부모님께 도움드려야 하는 집은 아니고, 대학교 등록금 내어주시고 대학생때까지 달마다 살아갈 만큼의 용돈을 주시는 부모님이 만드신 가정에서 태어나고 컸습니다. 이것은 매우 감사하게 생각하고 있습니다. 하지만 되도록 스스로 독립하려고도 많이 노력했다고 말하고 싶습니다. 신문배달도 해보고, 복조리도 팔아보고, 카페 알바도 해보고, 대학생되어서는 석사과정 마칠 때까지 과외를 엄청나게 했습니다. 비싼 사립 고등학교(외국어 고등학교)를 나왔는데, 그 때부터 성적이 잘 나온 학기 몇 번은 장학금을 받았습니다. 대학교 와서도 거의 전 학기 부분이더라도 성적장학금을 받았고, 대학원 부터는 학교에서 주는 돈으로 공부했고 집에서는 용돈도 받지 않았습니다. 어학연수갈 때도 부모님께 손을 벌리긴 했는데 (엄마, 아빠 감사합니다.), 들어간 비용의 반 이상은 스스로 충당했습니다. 1년 휴학하고 6개월은 아르바이트로 돈 벌었고, 영국에서도 스시집에서 아르바이트 했습니다.\n부모님 두 분 다 고등학교를 졸업하시고 바로 산업전선에 뛰어드신 분들이신데, 제가 고등학교를 다닐 무렵 아버지께서 대학교 입학하셔서 공부를 하셨습니다. 그즈음 어느 날, 아버지께서 술 한잔 하시고는 \u0026quot;아빠는 참 어렵게 공부했는데 그런 환경을 너에게 물려주고 싶지 않다.\u0026quot; 라고 본인이 공부하신 얘기하셨습니다. 이게 참 기억에 남아서, 아빠처럼 가정 형편 때문에 배움을 포기하셔야 했던 분들을 돕고 싶었습니다. 그래서 대학생이 되고 나서는 야학교 교사를 했습니다. (야학교에서 다양한 배경의 많은 사람들을 만났고, 그게 제가 세상을 바라보는 새로운 관점을 준 귀중한 자산이라고 생각합니다.) 석사과정때도 천주교에서 가정형편이 어려운 학생들을 위해 운영하는 공부방에서 교사로 봉사했습니다. 지금은 아무것도 못하고 있지만, 되도록 배우고자 하는 열정이 있는 분들에게 제 능력이 도움이 되는 그런 일을 하고 싶습니다.👩🏻‍🏫\n앞으로 더 많은 곳을 가고 싶고, 더 많이 알고 싶고, 그런 것들을 바탕으로 뭔가를 만들어 내고 싶습니다. 내가 만들어 낸 것들로 인해서 다른 사람들이 살아가는데 조금은 도움이 되는 그런 삶을 살고 싶습니다. 거창한 거 같지만 사실은, 인생에 특별한 계획이 없고 그냥... 그때 그때, 하고 싶은 거 (하지만 남에게 피해가 되지 않는 거) 하고 살고 싶습니다.\n이런 블로그 왜 하냐구요? 사람 만나는 걸 안 좋아해서 맨날 방에 쳐 박혀 있다 보니 심심합니다.\n기억을 잘 못해서 배운 것들을 계속 까먹습니다. 여기에 정리해 두고 필요할 때마다 쉽게 찾아 보고 싶고, 블로그 포스팅해야된다는 게 공부하는데 동기부여가 될 것 같아서요.\n거기에 더불어, 항공우주공학은 공부하고 싶어도 한국어로 된 자료가 많지 않습니다. 여기에 쓰는 것들이 항공공학도를 꿈꾸는 누군가에게 도움이 되길 바라겠습니다.\n","link":"https://dahjeong.github.io/kr/about/","section":"","tags":null,"title":"About Me"},{"body":"","link":"https://dahjeong.github.io/kr/tags/high-lift-device/","section":"tags","tags":null,"title":"high lift device"},{"body":"1. 고양력장치에 의한 양력 증가량 고양력장치를 사용하여 얻어지는 항공기의 최대 양력계수와 영 양력받음각 $\\alpha_{L=0}$ 의 증가량은 다음과 같다.\n$$\\Delta C_{Lmax} = \\Delta C_{lmax} \\left( \\frac{S_{flapped}}{S_{ref}} \\right) \\cos{\\Lambda_{H.L.}}$$\n$$\\Delta \\alpha_{L=0} = (\\Delta \\alpha_{L=0})_{\\text{airfoil}} \\left( \\frac{S_{\\text{flapped}}}{S_{ref}} \\right) \\cos{\\Lambda_{H.L.}}$$ 여기서 $S_{\\text{flapped}}$는 날개에 고양력장치가 설치되어 있는 부분의 면적을 말한다. 그리고 $\\Lambda_{H.L.}$ 은 플랩 힌지선의 후퇴각이다.\n1-1. Plain Flap\n$$\\Delta C_{l} = C_{l \\delta_{f}} \\delta_{f} K'$$\n여기서 플랩 각 양력선 기울기 $C_{l\\delta_{f}}$와 계수 K'는 아래의 그림을 통해서 구할 수 있다.\n1-2. Split Flap\n$$\\Delta C_{l} = k_{f} (\\Delta C_{l})_{c_f/{c=0.2}} $$\n이때 $k_{f}$와 $(\\Delta C_{l})_{c_f/c=0.2}$ 는 아래의 그림에서 구한다.\n1-3. Single Slotted Flap\n$$\\Delta C_{l} = C_{l\\alpha_{f}}\\alpha_{\\delta_{f}}\\delta_{f}$$\n이때 $\\alpha_{\\delta_{f}}$는 아래 그림에서 구할 수 있다.\n플랩 부분의 에어포일 양력선 기울기 $C_{l\\alpha_{f}}$는 다음과 같이 구할 수 있다.\n$$C_{l\\alpha_{f}}=C_{l\\alpha}(c'/c)$$\n여기서\n$$c'/c = 1+2(z_{fh}/c)\\tan(\\delta_{f}/2)$$\n또한 슬롯의 크기 $z_{fh}$는 아래 그림과 같다.\n1-4. Fowler Flap\n$$\\Delta C_{l} = C_{l\\alpha_{f}}\\alpha_{\\delta_{f}}\\delta_{f}$$\n여기서 플랩 에어포일의 양력선 기울기 $C_{l\\alpha_{f}}$는 다음과 같다.\n$$C_{l\\alpha_{f}}=C_{l\\alpha}(1+c_{f}/c)$$\n앞전 플랩(leading edge flap)이 에어포일의 양력계수에 미치는 영향은 앞전 플랩이 없는 경우에 대해서 다음과 같은 관계를 갖는다.\n$$c_{lmax(\\text{with L.E. flap})} = (c\u0026quot;/c)c_{lmax(\\text{without L.E. flap})}$$\n여기서 $c\u0026quot;$는 그림과 같다.\n2. 고양력장치 설계를 위한 양력 증가 요구분 추정 2-1. 최대 양력계수 $C_{Lmax}$, 이륙 최대 양력계수 $C_{LmaxTO}$, 착륙 최대 양력계수 $C_{LmaxL}$을 정한다.\n2-2. 실제 항공기 날개에서 양력 손실을 고려해서 앞에서 구한 $C_{Lmax}$ 값을 조정해 준다.\n$$ C_{Lmax_{W}} = 1.05 \\sim 1.1 C_{Lmax}$$\n이때 $L_{h}/\\bar{c}\u0026gt;5.0$ 이면 1.05를 사용하고 $L_{h}/\\bar{c}\u0026lt;3.0$이면 1.1을 사용한다. $L_{h}$는 항공기 무게중심에서 수평 꼬리 날개 또는 카나드의 공력 중심까지의 거리이다.\n2-3. 35$^{\\circ}$ 이하의 후퇴각이 있는 경우에 다음의 식을 사용하여 양력 계수를 조정한다.\n$$C_{Lmax_{W}swpt} = C_{Lmax_{W}unswpt}\\cos{\\Lambda_{c/4}}$$\n후퇴각이 0$^{\\circ}$ 인 경우에 최대 양력계수값을 다음과 같은 근사식을 통하여 검증한다.\n$$C_{Lmax_W} = k_{\\lambda}(C_{lmax_{Root}} + C_{lmax_{Tip}})/2$$ $$k_{\\lambda} = 0.88 \\text{ for } \\lambda = 1.0$$ $$k_{\\lambda} = 0.95 \\text{ for } \\lambda = 0.4$$\n여기서 2차원 에어포일의 최대 양력계수 $C_{lmax}$ 는 아래의 그림에서 구한다.\n이때 사용할 레이놀즈 수는 다음 식으로 구한다.\n$$R_{nr} = \\rho V c_{r}/\\mu \\text{ at the root}$$ $$R_{nt} = \\rho V c_{t}/\\mu \\text{ at the tip}$$\n2-4. 고양력장치로 발생시키고자 하는 양력계수의 증가량을 다음식으로 구한다.\n$$\\Delta C_{LmaxTO} = 1.05(C_{LmaxTO}- C_{Lmax})\\ \\Delta C_{LmaxL} = 1.05(C_{maxL}-C_{Lmax})$$\n여기서 1.05는 플랩을 이용하여 트림을 잡을 때 손실되는 것을 보상하는 값이다.\n$$\\Delta C_{lmax} = (\\Delta C_{Lmax}/ K_{\\Lambda})(S_{ref}/S_{flapped})$$\n여기서 $K_{\\Lambda}$는 플랩이 내려졌을 때 후퇴각의 영향이며 다음의 식으로 구한다.\n$$K_{\\Lambda} = (1-0.08\\cos^{2}\\lambda_{c/4})\\cos^{3/4}\\Lambda_{c/4}$$\n받음 각 0에서 에어포일의 양력계수 증가량 $\\Delta C_{l}$ 은 다음과 같다.\n$$\\Delta C_{l} = (1/K) \\Delta C_{lmax} $$\n여기서 K는 플랩 시위 비(Flap to Chord Ratio, $c_{f}/c$) 및 플랩의 종류에 따라서 다음의 그림을 통해서 구할 수 있다.\n","link":"https://dahjeong.github.io/kr/aircraft/high-lift-device/","section":"aircraft","tags":["high lift device"],"title":"고양력장치에 의한 양력곡선 변화"},{"body":"1. 큰 가로세로비(High Aspect Ratio)\n큰 가로세로비란, 주날개의 가로세로비가 기준 가로세로비 $A_{Low}$ 보다 큰 경우, $A \u0026gt; A_{Low}$ 를 말한다. 여기서 기준 가로세로비는 아래와 같다.\n$$A_{Low} = \\frac{3}{(C_{1}+1)\\cos\\Lambda_{LE}}$$\n여기서 $\\Lambda_{LE}$는 이고, $C_{1}$은 테이퍼 비의 함수로 아래의 그림과 같다.\n큰 가로세로비를 가지는 항공기의 최대양력 계수는 다음과 같다.\n$$C_{Lmax} = \\left(\\frac{C_{Lmax}}{C_{lmax}}\\right)C_{lmax}+\\Delta C_{L_{\\max}}$$\n여기서 $C_{lmax}$ 는 M=0.2일 때 에어포일의 최대양력계수이고 $(C_{Lmax}/C_{lmax})$ 는 다음과 같다.\n$$\\left(\\frac{C_{Lmax}}{C_{lmax}}\\right) = A-B \\cdot \\Delta y'$$\n여기서 A, B와 $\\Delta y'$ 은 $\\Lambda_{LE}$를 이용해서 아래와 같이 구할 수 있다.\n$$A=0.895+0.0028\\Lambda_{LE}+6.57\\times10^{-5}(\\Lambda_{LE})^{2}$$ $$B=0.0011+0.0053\\Lambda_{LE}+0.00011(\\Lambda_{LE})^{2}$$ $$\\Delta y'= 0~~~~~~~~~~~~~: \\Delta y \u0026lt;1.4$$ $$~~~~~~~~~~~~~~~~~~ = \\Delta y -1.4 : 1.4 \\le \\Delta y \\le 2.5 $$ $$~~~~~~ = 1.1~~~~~~~~~~: \\Delta y \u0026gt; 2.5$$\n여기서 $\\Delta y$는 앞전 두께인자이며 아래의 표로 구한다.\n에어포일 계열 $\\Delta y$ 4계열 26% of t/c 5계열 26% of t/c 64계열 21.3% of t/c 65계열 19.3% of t/c Biconvex 11.8% of t/c 위의 식에서 $\\Delta C_{Lmax}$는 $M=0.2$ 이상의 마하수에서의 양력 증가분이며 아래의 그림을 이용해서 구한다.\n최대 양력계수에서의 받음각 $\\alpha_{\\max}$는 아래의 식으로 구한다.\n$$\\alpha_{\\max}=\\frac{C_{Lmax}}{C_{L\\alpha}}+\\alpha_{L=0} + \\Delta \\alpha_{\\max}$$\n여기서 $C_{Lmax}$는 앞에서 구한 값을 사용한다. $C_{L\\alpha}$ 도 이전 포스트의 양력계수 기울기에서 구한 값을 이용한다. $\\Delta \\alpha_{\\max}$ 는 $\\Lambda_{LE}$ 와 앞전 두께인자 $\\Delta y$, 아래 그림을 이용해서 구한다.\n2. 작은 가로세로비(Low Aspect Ratio)\n작은 가로세로비란, 주날개의 가로세로비가 기준 가로세로비 $A_{Low}$ 보다 작은 경우, $A \u0026lt;\u0026gt; A_{Low}$ 를 말한다. 이때의 최대양력 계수는 다음과 같다.\n$$C_{Lmax} = (C_{Lmax})_{base}+\\Delta C_{Lmax}$$\n여기서 $(C_{Lmax})_{base}$는 아래의 그림을 이용하여 구한다. $\\beta = \\sqrt{1-M^{2}}$ 이다.\n그리고 $\\Delta C_{Lmax}$ 는 마하수에 대한 최대 양력계수의 증가분이며 다음 그림을 이용해서 구한다.\n최대 양력계수에서의 받음각 $\\alpha_{\\max}$는 다음과 같다.\n$$\\alpha_{\\max} = (\\alpha_{\\max})_{base} + \\Delta \\alpha_{\\max}$$\n여기서 $(\\alpha_{\\max})_{base}$ 는 저속($M=0.2$ 부근)에서의 $\\alpha_{\\max}$이고 아래의 그림을 이용하여 구한다.\n그리고 $\\Delta \\alpha_{\\max}$는 마하수 증가에 따른 보정 항이며 다음 그림을 이용해서 구한다.\n3. 전체 항공기 최대 양력계수, $C_{Lmax}$ 전체 항공기 최대 양력계수 $C_{Lmax}$는 다음과 같다.\n$$C_{Lmax} = (C_{Lmax})_{w} + (\\Delta C_{Lmax})_{T}$$\n여기서 $(\\Delta C_{Lmax})_{T}$는 꼬리날개에 의한 최대양력계수 증가분이다.\n$$(\\Delta C_{Lmax})_{T} = (C_{L\\alpha})_{T} \\cdot \\sin\\alpha_{\\max} \\cdot \\cos^{2}\\alpha_{\\max}$$\n여기서 $(C_{L\\alpha})_{T}$는 꼬리날개 양력계수 기울기 이다.\n","link":"https://dahjeong.github.io/kr/aircraft/maximum-lift-coefficient/","section":"aircraft","tags":["lift"],"title":"최대 양력 계수 추정"},{"body":"1. 날개의 양력곡선 기울기 $(C_{L\\alpha})_{W}$ 날개의 양력곡선 기울기 $(C_{L\\alpha})_{W}$ 는 속도 영역에 따라 각각 다른 경험식을 적용한다.\n1-1. 아음속 $$(C_{L \\alpha})_{W} = \\frac{ \\pi A_{\\text{effective}} }{1+\\sqrt{1+[1-(M \\cos{ \\Lambda_{c/2} })^{2}] (\\frac{A}{2\\cos{\\Lambda_{c/2}}})^{2}}}$$\n여기서 A는 날개의 가로세로비이고, $A_{\\text{effective}}$는 날개 끝 판(wing tip plate)이나 윙렛이 있는 경우 유효 가로세로비이며 다음과 같이 구한다.\n날개 끝 판 $A_{\\text{effective}} = A(1+1.9h/b)$\n윙렛 $A_{\\text{effective}} \\approx 1.2A$\n1-2. 초음속 아래의 이차원 선형 이론에 기초한 경험식을 이용하여 구한다.\n$$(C_{L\\alpha})_{W} = \\frac{4}{\\sqrt{M^{2}-1}}$$\n(단, $M\u0026gt;1/ \\cos\\Lambda_{LE}$)\n또는 DATACOM Method를 이용한다.\n1-3. 천음속 아음속에서 구한 값과 초음속에서 구한 값 사이를 부드러운 곡선으로 연결한다.\n2. 수평꼬리날개에 의한 양력곡선 기울기 증가분 $\\Delta(C_{L\\alpha})_{T} $ $$\\Delta (C_{L \\alpha})_{T} = (C'_{L\\alpha})_{T} \\left( 1- \\frac{\\partial \\epsilon}{\\partial \\alpha} \\right)\\frac{q_{t}}{q_{\\infty}} \\frac{S_{T}}{S_{ref}}$$\n여기서 $S_{T}$는 수평꼬리날개 면적, $S_{ref}$는 주날개 면적, $\\frac{q_{t}}{q_{\\infty}}$는 꼬리날개 동압이며 흔히 0.9이다. $\\frac{\\partial\\epsilon}{\\partial\\alpha}$는 저속 내리흐름 기울기(Low Speed Downwash Gradient)이고 아래와 같다.\n$$\\frac{\\partial \\epsilon}{\\partial \\alpha} = \\frac{21(C_{L\\alpha})_{W}}{A^{0.725}} \\left(\\frac{\\bar{C}}{l_{h}} \\right)_{0} \\left( \\frac{10-3\\lambda}{7} \\right) \\left(1-\\frac{h_{t}}{b} \\right)$$\n여기서 $b$는 날개 길이(span)이다.\n3. 카나드에 의한 양력곡선 기울기 증가분 $\\Delta(C_{L\\alpha})_{C}$ $$\\Delta(C_{L \\alpha})_{C} = (C'_{L \\alpha})_{C} \\left( 1 + \\frac{\\partial \\epsilon_{u}}{\\partial \\alpha} \\right) \\frac{S_{C}}{S_{ref}}$$\n여기서 $\\frac{\\partial \\epsilon_{u}}{\\partial \\alpha}$는 저속 올려흐름 기울기(Low speed Upwash Gradient)이다.\n$$\\frac{\\partial \\epsilon_{u}}{\\partial \\alpha} = (0.3A^{0.3}-0.33)\\left(\\frac{l_{c}}{\\bar{c}} \\right)^{(1.04+6A^{-1.7})}$$\n4. 전체 양력곡선 기울기 $C_{L\\alpha} = dC_{L/d\\alpha}$ 4-1. 아음속\n$$C_{L\\alpha} = (C_{L\\alpha})_{W-B} + \\Delta(C_{L\\alpha})_{T} + \\Delta(C_{L\\alpha})_{C}$$\n여기서 $(C_{L\\alpha})_{W-B}$는 동체-날개 조합의 양력곡선 기울기 이다.\n$$(C_{L\\alpha})_{W-B} = (C_{L\\alpha})_{W} K_{B}$$\n또한 $(C_{L\\alpha})_{W}$ 은 앞에서 구한 날개만의 양력곡선 기울기이고 $K_{B}$는 동체의 양력영향인자(fuselage lift factor)이다.\n$$K_{B} = (1+d/b)(1-d/b)^{f}$$\n$d$는 동체의 지름, $b$는 날개의 길이이고 f는 다음 식과 같다.\n$$f=(16+3A^{2})/(8+5A^{2})$$\n$A$는 날개의 가로세로비(aspect ratio)\n4-2. 초음속\n$$C_{L\\alpha} \\approx (C_{L\\alpha})_{W-B} = (C_{L\\alpha})_{W} K_{B}$$\n초음속 역역의 동체의 양력영향인자(fuselage lift factor) $K_{B}$는 다음과 같다.\n$$K_{B} =1.07(1+d/b)^{2}$$\n","link":"https://dahjeong.github.io/kr/aircraft/lift-curve/","section":"aircraft","tags":["lift"],"title":"양력 곡선 기울기 추정"},{"body":"1. 설계 이륙 총 중량 예측 1-1. 최대양항비 (Maximum Lift and Drag ratio) 추정\n유사항공기의 표피 면적비를 그래프를 이용하여 표피 면적비를 구함.\n$$\\frac{S_{wet}}{S_{ref}}$$\n$S_{wet}$: 항공기 표피 면적비 (공기와 접촉하고 있는 면적 전체)\n$S_{ref}$: 항공기 날개 면적 (항공기 위에서 projection 했을 때 면적)\n가로세로비(A)를 특정 값으로 결정하면 표피 면적 가로세로비를 구함.\n$$A_{wet} = A/(S_{wet}/S_{ref})$$\n그림에서 최대 양항비 $\\left( (\\frac{L}{D})_{max} \\right)$를 추정.\n1-2. 연료중량비 (Fuel and Weight ratio) 추정\nSTTO(Start, Taxi, and Take-off) $$W_{1}/W_{0} = 0.97$$\n상승(Climb) $$W_{2}/W_{1} = 0.985$$\n순항(Cluise) 순항거리(R)와 순항속도(V) 가 주어짐.\n비연료소모율은\n$$C=C_{bhp} \\frac{V}{550 \\nu_{p}} $$\n표로 부터 순항상태의 엔진 비연료 소모율($C_{bhp}:lb(hr-bhp)$)를 구함.\n프로펠러 항공기의 최적 순항 시의 양항비는\n$$(L/D){cruise} = (L/D){max}$$\n이고 제트 항공기의 경우 최적 순항 시의 양항비는\n$$(L/D){cruise} = 0.866(L/D){max}$$\n이를 Breguet range equation에 대입하면 중량비를 추정할 수 있음.\n$$W_{3}/W_{2}=e^{-\\frac{RC}{V(L/D)}}$$\n로이터(Loiter) 로이터 시간(E)이 주어짐. 표로 부터 로이터 시의 엔진 비연료 소모율($C_{bhp}:lb(hr-bhp)$)를 구하고 위의 식을 이용하여 비연료소모율을 구함.\n제트 항공기의 로이터시 최적 양항비는 $(L/D){cruise} = (L/D){max}$ 임.\n$$W_{4}/W_{3} = e^{-\\frac{EC}{L/D}}$$\n하강(Decent) 하강 시에는 연료소모가 매우 적다고 가정함.\n$$W_{5}/W_{4} = 1$$\n착륙(Land) $$W_{6}/W_{5} = 0.995$$\nReserve reserve 조건이 속도(V)와 지속 시간(t)으로 주어짐.\nreserve 거리는\n$$R = Vt$$\n양항비, 비연료소무율은 순항과 같은 값을 사용함.\n$$W_{7}/W_{6}=e^{-\\frac{RC}{V(L/D)}}$$\n최종 연료중량비는 예비연료비 5% 또는 10%와 갇힌 연료 1%를 더하여 계산함.\n$$W_{f}/W_{0} = 1.06 \\left( 1-\\frac{W_{7}}{W_{0}} \\right)$$\n1-3. 공허중량비 (Empty weight ratio, $W_{e}$) 추정\n표로 부터 regression 계수를 찾아 아래 식에 대입함.\n$$W_{e}/W_{0} = AW_{0}^{C}K_{vs}$$\n여기서 $K_{vs} = $ variable sweep constant\n= 1.04 if variable sweep\n= 1.00 if fixed sweep\n1-4. 설계 이륙총중량 (Design takeoff gross weight, $W_{0}$) 추정.\n승무원 하중($W_{crew}$), 유상하중($W_{payload}$)이 주어지면 아래의 식을 반복 계산하여 설계 이륙총중량($$W_{0}$$)을 찾음.\n$$W_{0}=\\frac{W_{crew}+W_{payload}}{1-(W_{f}/W_{0})-(W_{e}/W_{0})}$$\n2. 양항곡선 추정 2-1. 표피면적($S_{wet}$)\n항공기의 설계 이륙총중량으로부터 항공기 표피면적을 구함.\n$$log_{10}S_{wet}=c+dlog_{10}W_{0}$$\n여기서 계수 c와 d는 regression 계수이며 항공기 종류에 따라 아래의 표과 같이 결정됨.\n2-2. 등가유해면적(equivalent parasite area, f)\n등가표면마찰계수(equivalent skin friction coefficient, $c_{f}$)를 가정하면 상관 계수 a, b와 항공기 표피면적($S_{wet}$)을 이용하여 등가유해면적을 구함.\n$c_{f}$가 작을 수록 항공기의 표면이 매끄럽게 제작된 것을 의미함.\n$$log_{10}f=a+blog_{10}S_{wet}$$\n2-3. 날개면적($S_{ref}$)\n$W_{0}/S_{ref}$를 특정값으로 가정하고 앞에서 구한 설계 이륙총중량($W_{0}$)을 이용하여 날개면적($S_{ref}$)을 구함.\n2-4. 최소항력계수($C_{D_{0}}$)\n최소항력계수는 점성에 의한 표면마찰과 관계있으며 아래의 식을 통해 구함.\n$$C_{D_{0}}=\\frac{f}{S_{ref}}$$\n2-5. 항력($C_{D}$)\n항공기의 항력은 최소항력계수와 양력에 의한 유도항력의 합으로 구할 수 있음.\n$$C_{D}=C_{D_{0}}+KC_{L}^{2}$$\n여기서\n$$K=\\frac{1}{\\pi Ae}$$\n이때 e는 Oswald span efficiency로 타원형 양력분포의 날개는 e=1 임. 일반적으로 0.7에서 0.85의 값을 갖음.\n아음속 날개의 경우:\n$$e=1.78(1-0.045A^{0.68})-0.64$$\n앞전 후퇴각이 30도보다 큰 날개의 경우:\n$$e=4.61(1-0.045A^{0.68})(cos\\Lambda_{LE})^{0.15}-3.1$$\n3. 기능성능 요구도 3-1. 최대속도\n특정고도에서 이용 추력(available thrust)을 T라고 할 때, 항공기의 최대속도는 이용 추력이 항력보다 클 때 발생하므로 아래와 같은 식을 만족해야 함.\n$$\\left( \\frac{T_{altitude}}{W_{remained}} \\right) \\geq \\frac{C_{D_{0}}q}{W_{remained}/S}+\\frac{K}{q} \\frac{W_{remained}}{S}$$\n피스톤엔진과 프로펠러 항공기 추력 특성은\n$$ T_{SL}=550hp_{SL} \\frac{nu_{p}}{V} $$\nhigh bypass 터보팬엔진의 경우 고도에 따른 추력을 보정해 주어야 함.\n$$ T_{altitude}=\\frac{0.1}{M_{\\inf}}\\sigma T_{SL} = \\frac{a\\sigma}{10V}T_{SL} $$\n연료사용에 따른 중량도 보정해 주어야 함.\n$$ W_{remained} = \\frac{W_{remained}}{W_{0}}W_{0} $$\n3-2. 상승률\n항공기의 비행경로각이 작을 경우 상승률은\n$$ R/C = V \\left( \\frac{T}{W}-\\frac{D}{W} \\right) = V \\left( \\frac{T}{W}-\\frac{qC_{D_{0}}}{(W/S)} -\\frac{K}{q} \\frac{W}{S} \\right) $$\n피스톤엔진과 프로펠러 항공기의 추력 특성과 중량 보정을 포함하면\n$$ R/C = 550\\nu_{p} \\left( \\frac{hp_{SL}}{W_{0}} \\right)-\\frac{1}{2}\\rho V^{3} \\frac{C_{D_{0}}}{(W_{0}/S)}-\\frac{2K}{\\rho V} \\left( \\frac{W_{0}}{S} \\right) $$\n최대상승률이 발생하는 속도는 R/C를 속도로 미분하여 얻을 수 있음.\n$$ V=\\sqrt{\\frac{2}{\\rho} \\left( \\frac{W_{0}}{S} \\right)\\sqrt{\\frac{K}{3C_{D_{0}}}}} $$\nhigh bypass 터보팬엔진 항공기의 추력 특성과 중량 보정을 포함하면\n$$ R/C = V \\left( \\left(\\frac{W_{0}}{W_{remained}} \\right)\\frac{a\\sigma}{10V} \\left(\\frac{T_{SL}}{W_{0}} \\right)-\\left(\\frac{W_{0}}{w_{remained}} \\right)\\frac{qC_{D_{0}}}{(W_{0}/S)}-\\frac{K}{q} \\left(\\frac{W_{remained}}{W_{0}} \\right)\\left(\\frac{W_{0}}{S} \\right)\\right) $$\n최대상승률이 발생하는 속도는\n$$ V = \\sqrt{\\frac{2}{\\rho} \\left(\\frac{W_{remained}}{W_{0}} \\right) \\left(\\frac{W_{0}}{S} \\right)\\sqrt{\\frac{K}{3C_{D_{0}}}}} $$\n3-3. 상승한계\n표에서 항공기 타입에 따른 최대 상승률(R/C)을 찾고 상승 한계에 적용함.\n피스톤엔진과 프로펠러 항공기의 상승한계는\n$$ \\left( \\frac{hp_{SL}}{W_{0}} \\right) \\geq \\frac{\\rho C_{D_{0}}}{1100 \\nu} \\left( \\frac{V^{3}}{W_{0}/S} \\right)+\\left( \\frac{K}{275 \\nu_{p}} \\right)\\frac{1}{V} \\left( \\frac{W_{0}}{S} \\right)+\\frac{R/C}{550 \\nu_{p}} $$\nhigh bypass 터보팬엔진 항공기의 상승한계는\n$$ \\left( \\frac{T_{SL}}{W_{0}} \\right) \\geq \\frac{r\\rho C_{D_{0}}}{a \\sigma} \\frac{V^{3}}{(W_{0}/S)}+\\left( \\frac{W_{remained}}{W_{0}} \\right)^{2} \\left( \\frac{a \\sigma K}{5\\rho} \\right) \\frac{1}{V} \\left( \\frac{W_{0}}{S} \\right) $$\n4. 활주성능 요구도 4-1. 이륙거리\n이륙거리는 지상활주거리(Ground roll)는 정지상태에서 가속하여 속도가 이륙속도(통상 실속속도의 1.1배)에 이르렀을 때, 즉 바퀴가 지면을 떠날 때까지의 활주거리임.\n제트 항공기의 경우\n$$ \\frac{W_{0}}{S} \\leq (TOP) \\sigma C_{L_{TO}} \\left( \\frac{T_{SL}}{W_{0}} \\right) $$\n프로펠러 항공기의 경우\n$$ \\frac{W_{0}}{S} \\leq (TOP)\\sigma C_{L_{TO}} \\left( \\frac{hp_{SL}}{W_{0}} \\right) $$\n4-2. 착륙거리\n착륙거리는 지상활주거리와 장애물 통과거리의 합임.\n$$ {\\frac{W_{0}}{S}} \\leq {\\frac{S_{landing}-S_{a}}{80} \\sigma C_{L_{max}} \\frac{W_{0}}{W_{remained}}} $$\n여기서 첫 항은 지상활주거리이며 바퀴가 접지하여 정지할 때까지의 거리를 의미함.\n$$S_{a}$$은 장애물 통과거리이며 항공기 고도 50ft에서부터 바퀴가 접지할 때까지의 거리를 의미함.\n$$S_{a}$$ = 1,000(여객기 등급, 여기서 활공각은 3도)\n= 600(경항공기, Power-off Approach)\n= 450(단거리 이착륙기, 활공각은 7도)\n4-3. 실속속도\n실속속도는 항공기가 최대양력계수 상태에서 등속수평비행하는 속도임.\nFAR23 규정에 따르면 총 이륙중량 12,500lb 이하의 항공기는 특별한 경우(다발엔진을 채택하거나 특별한 상승률을 요구하는 경우)가 아니면 실속속도가 61knots를 넘어서는 안됨.\n실속속도의 정의와 내부연료 70$$%$$를 고려하면 실속속도는\n$$ { \\frac{W_{0}}{S} } \\leq {\\frac{1}{2} \\rho V_{stall}^{2} C_{L_{max}} \\frac{W_{0}}{W_{70%}}} $$\n","link":"https://dahjeong.github.io/kr/aircraft/parameter-esitmation/","section":"aircraft","tags":null,"title":"설계 파라미터 추정"},{"body":"","link":"https://dahjeong.github.io/kr/tags/engine/","section":"tags","tags":null,"title":"engine"},{"body":"설계 항공기의 순항 비행 마하수, 고도, 필요 추력, 엔진 종류와 갯수, 해면 정지 추력(SLST, $T_{SL}$), 바이패스비(BPR), 비연료 소모율(SFC), 기관 무게(W), 기관 길이(L), 기관(팬) 지름(D)이 주어짐.\n(1) 분사 추진 계통 설계 예\n표준 대기표에서 순항고도에서 압력비, 온도비를 찾고 추력식에 대입한다.\n$$T_{H}=T_{SL} \\frac{P_{H}}{P_{SL}} \\frac{\\theta_{SL}}{\\theta_H}$$\n순항비행시 추력은 최대이륙 추력의 80%\n$$T_{ref}=0.8 * T_{H}$$\n마하수가 1보다 적으면 램효과에 의한 추력 증가를 고려하지 않는다. 기관당 필요추력은\n$$T_{ref_{engine}}=T_{ref}/n$$\n스케일 계수(scale factor, SF)는 설계 항공기의 필요추력과 표준 기관의 추력의 비이다.\n$$SF = T_{ref_{engine}}/T_{actual}$$\n$$T_{SL} = T_{SL_{actual}}(SF)$$\n$$L=L_{actual}(SF)^{0.4}$$\n$$D=D_{actual}(SF)^{0.5}$$\n$$W=W_{actual}(SF)^{1.1}$$\n이륙 거리 산정을 위해 필요한 전체 이륙 추력은 $$T_{take-off}=T_{SL} \\times \\text{(Number of Engines)}$$\n후연소기가 없는 아음속 항공기 기관($0 \\geq BPR \\geq 6.0$) $$W=0.084T^{1.1}e^{(-0.045BPR)}$$\n$$L=2.22T^{0.4}M^{0.2}$$\n$$D=0.3937T^{0.5}e^{(0.04BPR)}$$\n$$SFC_{maxT}=0.67e^{(-0.12BPR)}$$\n$$T_{cruise}=0.60T^{0.9}e^{(0.02BPR)}$$\n$$SFC_{cruise}=0.88e^{(-0.05BPR)}$$\n후연소기가 있는 초음속 전투기 및 폭격기($1 \\geq M \\geq 2.5$, $0 \\geq BPR \\geq 1.0$) $$W=0.063T^{1.1}M^{0.25}e^{(-0.81BPR)}$$\n$$L=3.06T^{0.4}M^{0.2}$$\n$$D=0.288T^{0.5}e^{(0.04BPR)}$$\n$$SFC_{maxT}=2.1e^{(-0.12BPR)}$$\n$$T_{cruise}=1.6T^{0.74}e^{(0.023BPR)}$$\n$$SFC_{cruise}=1.04e^{-(0.186BPR)}$$\n","link":"https://dahjeong.github.io/kr/aircraft/engine-design/","section":"aircraft","tags":["engine"],"title":"추진 계통 설계"},{"body":"","link":"https://dahjeong.github.io/kr/etc/","section":"etc","tags":null,"title":""},{"body":"Breguet range equation은 비행기가 얼마나 멀리 날 수 있는가를 나타내는 방정식이다.\n$W$의 무게를 갖는 비행기가 steady, level flight 중 이라고 생각해 보자. 총 무게의 변화는 연료의 변화와 같다.\n$$\\frac{dW}{dt} = g\\dot{m_f} = \\frac{T}{I_{sp}}$$\n$W$: 비행기 총 중량 $t$: 시간 $g$: 중력가속도 $\\dot{m_f}$:연료변화량 $T$: 추력 $I_{sp}$: efficiency\nFor steady, level flight 에서는 $T = D$, $L = W$, or\n$$W=L=D \\left( \\frac{L}{D} \\right)=T \\left( \\frac{L}{D} \\right)$$\n따라서, 항공기 총 무게의 변화량은\n$$\\frac{dW}{dt} =-\\frac{W}{(L/D)I_{sp}}$$\n$L/D$ and $I_{sp}$ 이 flight path를 따라 constant 라고 가정하면:\n$$\\frac{dW}{W} = -\\frac{dt}{(L/D)I_{sp}}$$\n적분하면\n$$\\ln\\left(\\frac{W}{W_i}\\right)=-\\frac{t}{(L/D)I_{sp}}$$\n$W_i$: 비행 초기 항공기 무게\n$W_f$: 비행 종료 시 항공기 무게\n비행 초기 및 종료 시간에 따라 적분하면\n$$\\frac{L}{D}I_{sp} \\ln\\left(\\frac{W_i}{W_f}\\right)=t_f$$\n$t_\\textrm{initial}$: 비행 시작 시간, $t_\\textrm{initial}=0$\n$t_f$: 비행 종료 시간\n비행 영역(Flight Range)은 항공기 속도($V$)와 시간($t$)의 곱이므로\n$$ Range = V t_f = V \\times \\frac{L}{D} \\times I_{sp} \\times \\ln \\left( \\frac{W_i}{W_f} \\right)$$\n","link":"https://dahjeong.github.io/kr/etc/breguet-range-equation/","section":"etc","tags":null,"title":"Breguet range equation"},{"body":"","link":"https://dahjeong.github.io/kr/categories/misc/","section":"categories","tags":null,"title":"MISC"},{"body":"보일의 법칙(Boyle) (이상)기체의 온도와 양이 일정할 때, 압력과 부피는 반비례한다.\n=\u0026gt; 압력과 부피의 곱이 항상 일정\n샤를의 법칙(Charles) (이상)기체의 압력과 양이 일정할 때, 부피와 온도는 정비례한다.\n=\u0026gt; 절대 온도 0에서 기체 부피 0\n아보가드로의 법칙(Avogadro) (이상)기체의 압력과 온도가 일정할 때, 기체의 몰 수와 부피는 정비례한다.\n아보가드로 수는 1몰에 들어 있는 구성입자 수\n$$6.02 \\times 10^{23} mol^{-1}$$\n이상기체 상태방정식은 위의 세 법칙을 집대성한 것\n$$PV = n \\times R \\times T$$\n$P$: 압력 (Pressure)\n$V$: 부피 (Volume)\n$n$: 몰수 (Mole)\n$R$: 이상기체 상수 (Ideal gas constant)\n$T$: 온도(Temperature)\n이상기체란 무엇인가?\n기체 분자들이 자신의 크기보다 훨씬 큰 거리를 두고 멀리 떨어져 있다. 기체 입자의 부피는 0으로 간주한다.\n기체 분자들은 끊임없이 무질서하게 움직인다.\n기체 분자들은 충돌할 때를 제외하고 아무런 힘이 작용하지 않으며 일정한 속도의 직선운 동을 한다.\n기체 분자와 벽면과의 충돌은 완전 탄성 충돌이며, 충돌로 인한 에너지 손실이 일어나지 않는다.\n","link":"https://dahjeong.github.io/kr/etc/ideal-gas-law/","section":"etc","tags":null,"title":"Ideal Gas law (이상기체법칙)"},{"body":"","link":"https://dahjeong.github.io/kr/machine/","section":"machine","tags":null,"title":""},{"body":"","link":"https://dahjeong.github.io/kr/movies/","section":"movies","tags":null,"title":""},{"body":"","link":"https://dahjeong.github.io/kr/music/","section":"music","tags":null,"title":""},{"body":"","link":"https://dahjeong.github.io/kr/travel/","section":"travel","tags":null,"title":""}]